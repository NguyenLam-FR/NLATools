var IgxGridComponent_1;
import { __decorate } from "tslib";
import { Component, ChangeDetectionStrategy, Input, Output, EventEmitter, ContentChild, ViewChildren, QueryList, ViewChild, TemplateRef, HostBinding, forwardRef } from '@angular/core';
import { GridBaseAPIService } from '../api.service';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxGridAPIService } from './grid-api.service';
import { cloneArray } from '../../core/utils';
import { IgxGroupByRowTemplateDirective, IgxGridDetailTemplateDirective } from './grid.directives';
import { IgxGridGroupByRowComponent } from './groupby-row.component';
import { takeUntil } from 'rxjs/operators';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxColumnResizingService } from '../resizing/resizing.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService, IgxGridCRUDService } from '../selection/selection.service';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridMRLNavigationService } from '../grid-mrl-navigation.service';
import { IgxRowIslandAPIService } from '../hierarchical-grid/row-island-api.service';
import { FilterMode } from '../common/enums';
let NEXT_ID = 0;
/**
 * Grid provides a way to present and manipulate tabular data.
 * @igxModule IgxGridModule
 * @igxGroup Grids & Lists
 * @igxKeywords grid, table
 * @igxTheme igx-grid-theme
 * @remarks
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 * @example
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
let IgxGridComponent = IgxGridComponent_1 = class IgxGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        this._id = `igx-grid-${NEXT_ID++}`;
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._filteredData = null;
        this.childDetailTemplates = new Map();
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.groupingExpansionStateChange = new EventEmitter();
        /**
         * Gets/Sets whether created groups are rendered expanded or collapsed.
         * @remarks
         * The default rendered state is expanded.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.groupsExpanded = true;
        /**
         * Gets the hierarchical representation of the group by records.
         * @example
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         */
        this.groupsRecords = [];
        /**
         * Emitted when columns are grouped/ungrouped.
         * @remarks
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onGroupingDone = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.detailTemplate = null;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Gets/Sets the array of data that populates the `IgxGridComponent`.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Gets/Sets an array of objects containing the filtered data.
     * @example
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * this.grid.filteredData = [...];
     * ```
     */
    get filteredData() {
        return this._filteredData;
    }
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Gets/Sets the total number of records in the data source.
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * Gets/Sets the group by state.
     * @example
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * this.grid.groupingExpressions = [...];
     * ```
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    set groupingExpressions(value) {
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        const oldExpressions = this.groupingExpressions;
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();
            this._gridAPI.arrange_sorting_expressions();
            this.notifyChanges();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            const groupedCols = [];
            const ungroupedCols = [];
            const groupedColsArr = newExpressions.filter((obj) => {
                return !oldExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const ungroupedColsArr = oldExpressions.filter((obj) => {
                return !newExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Gets/Sets a list of expansion states for group rows.
     * @remarks
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Gets/Sets whether the grouped columns should be hidden.
     * @remarks
     * The default value is "false"
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * @remarks
     * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * @example
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * Gets the list of group rows.
     * @example
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     */
    get groupsRowList() {
        const res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        const rList = this._groupsRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        }).sort((item1, item2) => item1.index - item2.index);
        res.reset(rList);
        return res;
    }
    /**
     * @hidden @internal
     */
    getDetailsContext(rowData, index) {
        return {
            $implicit: rowData,
            index: index
        };
    }
    /**
     * @hidden @internal
     */
    trackChanges(index, rec) {
        if (rec.detailsData !== undefined) {
            return rec.detailsData;
        }
        return rec;
    }
    /**
     * @hidden @internal
     */
    detailsViewFocused(container, rowIndex) {
        this.navigation.activeNode ? this.navigation.activeNode.row = rowIndex :
            this.navigation.activeNode = { row: rowIndex };
    }
    /**
     * @hidden @internal
     */
    get hasDetails() {
        return !!this.gridDetailsTemplate;
    }
    /**
     * @hidden @internal
     */
    getRowTemplate(rowData) {
        if (this.isGroupByRecord(rowData)) {
            return this.defaultGroupTemplate;
        }
        else if (this.isSummaryRow(rowData)) {
            return this.summaryTemplate;
        }
        else if (this.hasDetails && this.isDetailRecord(rowData)) {
            return this.detailTemplateContainer;
        }
        else {
            return this.recordTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    isDetailRecord(record) {
        return record.detailsData !== undefined;
    }
    /**
     * @hidden @internal
     */
    isDetailActive(rowIndex) {
        return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;
    }
    /**
     * @hidden @internal
     */
    get groupAreaHostClass() {
        return this.getComponentDensityClass('igx-drop-area');
    }
    /**
     * Gets/Sets the template reference for the group row.
     * @example
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * this.grid.groupRowTemplate = myRowTemplate;
     * ```
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the template reference of the `IgxGridComponent`'s group area.
     * @example
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * @remarks
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * @example
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.endEdit(true);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears grouping for particular column, array of columns or all columns.
     * @remarks
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * @example
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     * @param name Name of column or array of column names to be ungrouped.
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.notifyChanges(true);
    }
    preventHeaderScroll(args) {
        if (args.target.scrollLeft !== 0) {
            this.navigation.forOfDir().getScroll().scrollLeft = args.target.scrollLeft;
            args.target.scrollLeft = 0;
        }
    }
    /**
     * Returns if a group is expanded or not.
     * @param group The group record.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     */
    isExpandedGroup(group) {
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     * @param groupRow The group record to toggle.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     * @param groupRow The group record to fully expand.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     * @example
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     * @example
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    _setGroupColsVisibility(value) {
        if (this.columnList.length > 0 && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    /**
     * Gets if the grid's group by drop area is visible.
     * @example
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden @internal
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden @internal
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isDetailRecord(rowData)) {
            const cachedData = this.childDetailTemplates.get(rowData.detailsData);
            const rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : this.data.indexOf(rowData.detailsData);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData.detailsData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData),
                    templateID: 'detailRow-' + rowID
                };
            }
            else {
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData.detailsData,
                    templateID: 'detailRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData)
        };
    }
    /**
     * @hidden @internal
     */
    viewCreatedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            this.childDetailTemplates.set(args.context.$implicit, args);
        }
    }
    /**
     * @hidden @internal
     */
    viewMovedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            // view was moved, update owner in cache
            const key = args.context.$implicit;
            const cachedData = this.childDetailTemplates.get(key);
            cachedData.owner = args.owner;
        }
    }
    /**
     * @hidden @internal
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden @internal
     */
    chipsOrderChanged(event) {
        const newGrouping = [];
        for (let i = 0; i < event.chipsArray.length; i++) {
            const expr = this.groupingExpressions.filter((item) => {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipClicked(event) {
        const sortingExpr = this.sortingExpressions;
        const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            const sortingExpr = this.sortingExpressions;
            const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    get defaultTargetBodyHeight() {
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    }
    /**
     * @hidden @internal
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            const rowIndex = this.groupingResult.indexOf(row);
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden @internal
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getGroupByChipTitle(expression) {
        const column = this.getColumnByName(expression.fieldName);
        return (column && column.header) || expression.fieldName;
    }
    /**
     * @hidden @internal
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getColumnGroupable(fieldName) {
        const column = this.getColumnByName(fieldName);
        return column && column.groupable;
    }
    /**
     * @hidden @internal
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isDetailRecord(rowData)) {
                const cachedData = this.childDetailTemplates.get(rowData.detailsData);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.endEdit(true);
            this.summaryService.updateSummaryCache(args);
            this._headerFeaturesWidth = NaN;
        });
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length || this.hasDetails) {
            const source = [];
            const process = (record) => {
                if (record.expression || record.summaries || this.isDetailRecord(record)) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
        }
    }
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
};
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxGridComponent.prototype, "id", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "data", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "groupingExpressions", null);
__decorate([
    Output()
], IgxGridComponent.prototype, "groupingExpressionsChange", void 0);
__decorate([
    Input()
], IgxGridComponent.prototype, "groupingExpansionState", null);
__decorate([
    Output()
], IgxGridComponent.prototype, "groupingExpansionStateChange", void 0);
__decorate([
    Input()
], IgxGridComponent.prototype, "groupsExpanded", void 0);
__decorate([
    Input()
], IgxGridComponent.prototype, "hideGroupedColumns", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "dropAreaMessage", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "dropAreaTemplate", void 0);
__decorate([
    Output()
], IgxGridComponent.prototype, "onGroupingDone", void 0);
__decorate([
    ContentChild(IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective })
], IgxGridComponent.prototype, "groupTemplate", void 0);
__decorate([
    ContentChild(IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false })
], IgxGridComponent.prototype, "gridDetailsTemplate", void 0);
__decorate([
    ViewChildren(IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent })
], IgxGridComponent.prototype, "_groupsRowList", void 0);
__decorate([
    ViewChild('defaultDropArea', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "defaultDropAreaTemplate", void 0);
__decorate([
    ViewChild('groupArea')
], IgxGridComponent.prototype, "groupArea", void 0);
__decorate([
    ViewChild('record_template', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "recordTemplate", void 0);
__decorate([
    ViewChild('detail_template_container', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "detailTemplateContainer", void 0);
__decorate([
    ContentChild(IgxGridDetailTemplateDirective, { read: TemplateRef, static: false })
], IgxGridComponent.prototype, "detailTemplate", void 0);
__decorate([
    ViewChild('group_template', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "defaultGroupTemplate", void 0);
__decorate([
    ViewChild('summary_template', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "summaryTemplate", void 0);
IgxGridComponent = IgxGridComponent_1 = __decorate([
    Component({
        changeDetection: ChangeDetectionStrategy.OnPush,
        preserveWhitespaces: false,
        providers: [
            IgxGridNavigationService,
            IgxGridSummaryService,
            IgxGridSelectionService,
            IgxGridCRUDService,
            { provide: GridBaseAPIService, useClass: IgxGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxGridComponent_1) },
            IgxFilteringService,
            IgxColumnResizingService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService,
            IgxRowIslandAPIService
        ],
        selector: 'igx-grid',
        template: "<igx-grid-toolbar [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" role=\"toolbar\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\" (focus)=\"navigation.focusFirstCell()\"\n    [style.width.px]='calcWidth' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.headerNavigation($event)\" (scroll)=\"preventHeaderScroll($event)\" #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"pinnedWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\" (pointerdown)=\"$event.preventDefault()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" (pointerdown)=\"$event.preventDefault()\"  #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\" (pointerdown)=\"$event.preventDefault()\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (scroll)='preventContainerScroll($event)'\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf='data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData'>\n            <div #pinContainer *ngIf='pinnedData.length > 0'\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='getRowTemplate(rowData)'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [disabled]=\"disabledRow\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail='true' style=\"overflow:auto;width: 100%;\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)='detailsViewFocused(detailsContainer, rowIndex)' #detailsContainer [attr.data-rowindex]='rowIndex'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\" style='display:flex;'>\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]='detailTemplate'\n                    [ngTemplateOutletContext]='getDetailsContext(rowData, rowIndex)'>\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\"\n(focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth'  [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollSize\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n"
    })
], IgxGridComponent);
export { IgxGridComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUFFLHVCQUF1QixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQzNGLFNBQVMsRUFBRSxTQUFTLEVBQWMsV0FBVyxFQUE2QixXQUFXLEVBQUUsVUFBVSxFQUNwRyxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUV2RCxPQUFPLEVBQUUsVUFBVSxFQUFrQixNQUFNLGtCQUFrQixDQUFDO0FBRTlELE9BQU8sRUFBRSw4QkFBOEIsRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25HLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBS3JFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUUxRSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN4RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM3RixPQUFPLEVBQUUsbUJBQW1CLEVBQUUseUJBQXlC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QUF3QjtZQUN4QixxQkFBcUI7WUFDckIsdUJBQXVCO1lBQ3ZCLGtCQUFrQjtZQUNsQixFQUFFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUU7WUFDNUQsRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBZ0IsQ0FBQyxFQUFFO1lBQ2xGLG1CQUFtQjtZQUNuQix3QkFBd0I7WUFDeEIsbUJBQW1CO1lBQ25CLHlCQUF5QjtZQUN6QixzQkFBc0I7U0FDekI7UUFDRCxRQUFRLEVBQUUsVUFBVTtRQUNwQixpcG5CQUFvQztLQUN2QyxDQUFDO0dBQ1csZ0JBQWdCLENBdStCNUI7U0F2K0JZLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIFZpZXdDaGlsZHJlbixcbiAgICBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgVGVtcGxhdGVSZWYsIERvQ2hlY2ssIEFmdGVyQ29udGVudEluaXQsIEhvc3RCaW5kaW5nLCBmb3J3YXJkUmVmLCBPbkluaXQsIEFmdGVyVmlld0luaXQsIEhvc3RMaXN0ZW5lclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vZ3JpZC1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBjbG9uZUFycmF5LCBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4R3JpZERldGFpbFRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9ncmlkLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSBmcm9tICcuL2dyb3VwYnktcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJR3JvdXBCeUV4cGFuZFN0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJQmFzZUNoaXBFdmVudEFyZ3MsIElDaGlwQ2xpY2tFdmVudEFyZ3MsIElDaGlwS2V5RG93bkV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY2hpcHMvY2hpcHMtYXJlYS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneEZpbHRlcmluZ1NlcnZpY2UgfSBmcm9tICcuLi9maWx0ZXJpbmcvZ3JpZC1maWx0ZXJpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJR3JvdXBpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwaW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IElneENvbHVtblJlc2l6aW5nU2VydmljZSB9IGZyb20gJy4uL3Jlc2l6aW5nL3Jlc2l6aW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlIH0gZnJvbSAnLi4vc3VtbWFyaWVzL2dyaWQtc3VtbWFyeS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLCBJZ3hHcmlkQ1JVRFNlcnZpY2UgfSBmcm9tICcuLi9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4Rm9yT2ZTeW5jU2VydmljZSwgSWd4Rm9yT2ZTY3JvbGxTeW5jU2VydmljZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9yLW9mL2Zvcl9vZi5zeW5jLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZE1STE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vZ3JpZC1tcmwtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneFJvd0lzbGFuZEFQSVNlcnZpY2UgfSBmcm9tICcuLi9oaWVyYXJjaGljYWwtZ3JpZC9yb3ctaXNsYW5kLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IEZpbHRlck1vZGUgfSBmcm9tICcuLi9jb21tb24vZW51bXMnO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdyb3VwaW5nRG9uZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBleHByZXNzaW9uczogQXJyYXk8SVNvcnRpbmdFeHByZXNzaW9uPiB8IElTb3J0aW5nRXhwcmVzc2lvbjtcbiAgICBncm91cGVkQ29sdW1uczogQXJyYXk8SWd4Q29sdW1uQ29tcG9uZW50PiB8IElneENvbHVtbkNvbXBvbmVudDtcbiAgICB1bmdyb3VwZWRDb2x1bW5zOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50O1xufVxuXG4vKipcbiAqIEdyaWQgcHJvdmlkZXMgYSB3YXkgdG8gcHJlc2VudCBhbmQgbWFuaXB1bGF0ZSB0YWJ1bGFyIGRhdGEuXG4gKiBAaWd4TW9kdWxlIElneEdyaWRNb2R1bGVcbiAqIEBpZ3hHcm91cCBHcmlkcyAmIExpc3RzXG4gKiBAaWd4S2V5d29yZHMgZ3JpZCwgdGFibGVcbiAqIEBpZ3hUaGVtZSBpZ3gtZ3JpZC10aGVtZVxuICogQHJlbWFya3NcbiAqIFRoZSBJZ25pdGUgVUkgR3JpZCBpcyB1c2VkIGZvciBwcmVzZW50aW5nIGFuZCBtYW5pcHVsYXRpbmcgdGFidWxhciBkYXRhIGluIHRoZSBzaW1wbGVzdCB3YXkgcG9zc2libGUuICBPbmNlIGRhdGFcbiAqIGhhcyBiZWVuIGJvdW5kLCBpdCBjYW4gYmUgbWFuaXB1bGF0ZWQgdGhyb3VnaCBmaWx0ZXJpbmcsIHNvcnRpbmcgJiBlZGl0aW5nIG9wZXJhdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIGF1dG9HZW5lcmF0ZT1cImZhbHNlXCI+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwiZmlyc3RcIiBoZWFkZXI9XCJGaXJzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImxhc3RcIiBoZWFkZXI9XCJMYXN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwicm9sZVwiIGhlYWRlcj1cIlJvbGVcIj48L2lneC1jb2x1bW4+XG4gKiA8L2lneC1ncmlkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRTdW1tYXJ5U2VydmljZSxcbiAgICAgICAgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRDUlVEU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBHcmlkQmFzZUFQSVNlcnZpY2UsIHVzZUNsYXNzOiBJZ3hHcmlkQVBJU2VydmljZSB9LFxuICAgICAgICB7IHByb3ZpZGU6IElneEdyaWRCYXNlRGlyZWN0aXZlLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJZ3hHcmlkQ29tcG9uZW50KSB9LFxuICAgICAgICBJZ3hGaWx0ZXJpbmdTZXJ2aWNlLFxuICAgICAgICBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU3luY1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UsXG4gICAgICAgIElneFJvd0lzbGFuZEFQSVNlcnZpY2VcbiAgICBdLFxuICAgIHNlbGVjdG9yOiAnaWd4LWdyaWQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9ncmlkLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBHcmlkVHlwZSwgT25Jbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0IHtcbiAgICBwcml2YXRlIF9pZCA9IGBpZ3gtZ3JpZC0ke05FWFRfSUQrK31gO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nUmVzdWx0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nTWV0YWRhdGE6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBpbmdGbGF0UmVzdWx0OiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0V4cHJlc3Npb25zOiBJR3JvdXBpbmdFeHByZXNzaW9uW10gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0V4cGFuZFN0YXRlOiBJR3JvdXBCeUV4cGFuZFN0YXRlW10gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cFJvd1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwQXJlYVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ3JvdXBpbmdEaWZmZXI7XG4gICAgcHJpdmF0ZSBfZGF0YTtcbiAgICBwcml2YXRlIF9oaWRlR3JvdXBlZENvbHVtbnMgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kcm9wQXJlYU1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGlkYCBhdHRyaWJ1dGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2lkXT1cIidpZ3gtZ3JpZC0xJ1wiIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgcHVibGljIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBhcnJheSBvZiBkYXRhIHRoYXQgcG9wdWxhdGVzIHRoZSBgSWd4R3JpZENvbXBvbmVudGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBkYXRhKCk6IGFueVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBkYXRhKHZhbHVlOiBhbnlbXSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgIHRoaXMuc3VtbWFyeVNlcnZpY2UuY2xlYXJTdW1tYXJ5Q2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkR2VuZXJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgZGF0YS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyZWREYXRhID0gdGhpcy5ncmlkLmZpbHRlcmVkRGF0YTtcbiAgICAgKiB0aGlzLmdyaWQuZmlsdGVyZWREYXRhID0gWy4uLl07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmVkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkRGF0YTtcbiAgICB9XG5cbiAgICBzZXQgZmlsdGVyZWREYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkRGF0YSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBmb3IgcmVtb3RlIGdyaWQgdmlydHVhbGl6YXRpb24gdG8gZnVuY3Rpb24gd2hlbiBpdCBpcyBib3VuZCB0byByZW1vdGUgZGF0YS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBpdGVtQ291bnQgPSB0aGlzLmdyaWQxLnRvdGFsSXRlbUNvdW50O1xuICAgICAqIHRoaXMuZ3JpZDEudG90YWxJdGVtQ291bnQgPSA1NTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgdG90YWxJdGVtQ291bnQoY291bnQpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci50b3RhbEl0ZW1Db3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgZ2V0IHRvdGFsSXRlbUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci50b3RhbEl0ZW1Db3VudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBfZ3JpZEFQSSgpOiBJZ3hHcmlkQVBJU2VydmljZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRBUEkgYXMgSWd4R3JpZEFQSVNlcnZpY2U7XG4gICAgfVxuICAgIHByaXZhdGUgX2ZpbHRlcmVkRGF0YSA9IG51bGw7XG5cbiAgICBwcml2YXRlIGNoaWxkRGV0YWlsVGVtcGxhdGVzOiBNYXA8YW55LCBhbnk+ID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBncm91cCBieSBzdGF0ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBCeVN0YXRlID0gdGhpcy5ncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICogdGhpcy5ncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnMgPSBbLi4uXTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFN1cHBvcnRzIHR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgWyhncm91cGluZ0V4cHJlc3Npb25zKV09XCJtb2RlbC5ncm91cGluZ0V4cHJlc3Npb25zXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBncm91cGluZ0V4cHJlc3Npb25zKCk6IElHcm91cGluZ0V4cHJlc3Npb25bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zO1xuICAgIH1cblxuICAgIHNldCBncm91cGluZ0V4cHJlc3Npb25zKHZhbHVlOiBJR3JvdXBpbmdFeHByZXNzaW9uW10pIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTWF4aW11bSBhbW91bnQgb2YgZ3JvdXBlZCBjb2x1bW5zIGlzIDEwLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEV4cHJlc3Npb25zOiBJR3JvdXBpbmdFeHByZXNzaW9uW10gPSB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IG5ld0V4cHJlc3Npb25zOiBJR3JvdXBpbmdFeHByZXNzaW9uW10gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdFeHByZXNzaW9ucyA9IGNsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnNDaGFuZ2UuZW1pdCh0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zKTtcbiAgICAgICAgdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucyA9IGNsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fZ3JpZEFQSS5ncmlkKSB7XG4gICAgICAgICAgICAvKiBncm91cGluZyBzaG91bGQgd29yayBpbiBjb25qdW5jdGlvbiB3aXRoIHNvcnRpbmdcbiAgICAgICAgICAgIGFuZCB3aXRob3V0IG92ZXJyaWRpbmcgc2VwYXJhdGUgc29ydGluZyBleHByZXNzaW9ucyAqL1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlHcm91cGluZygpO1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSS5hcnJhbmdlX3NvcnRpbmdfZXhwcmVzc2lvbnMoKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0dGVyIGNhbGxlZCBiZWZvcmUgZ3JpZCBpcyByZWdpc3RlcmVkIGluIGdyaWQgQVBJIHNlcnZpY2VcbiAgICAgICAgICAgIHRoaXMuc29ydGluZ0V4cHJlc3Npb25zLnVuc2hpZnQuYXBwbHkodGhpcy5zb3J0aW5nRXhwcmVzc2lvbnMsIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5pdCAmJiBKU09OLnN0cmluZ2lmeShvbGRFeHByZXNzaW9ucykgIT09IEpTT04uc3RyaW5naWZ5KG5ld0V4cHJlc3Npb25zKSAmJiB0aGlzLmNvbHVtbkxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRDb2xzOiBJZ3hDb2x1bW5Db21wb25lbnRbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdW5ncm91cGVkQ29sczogSWd4Q29sdW1uQ29tcG9uZW50W10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRDb2xzQXJyID0gbmV3RXhwcmVzc2lvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW9sZEV4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cGVkQ29sc0Fyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBlZENvbHMucHVzaCh0aGlzLmdldENvbHVtbkJ5TmFtZShlbGVtLmZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCB1bmdyb3VwZWRDb2xzQXJyID0gb2xkRXhwcmVzc2lvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW5ld0V4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bmdyb3VwZWRDb2xzQXJyLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICB1bmdyb3VwZWRDb2xzLnB1c2godGhpcy5nZXRDb2x1bW5CeU5hbWUoZWxlbS5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgICAgICBjb25zdCBncm91cGluZ0RvbmVBcmdzOiBJR3JvdXBpbmdEb25lRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBuZXdFeHByZXNzaW9ucyxcbiAgICAgICAgICAgICAgICBncm91cGVkQ29sdW1uczogZ3JvdXBlZENvbHMsXG4gICAgICAgICAgICAgICAgdW5ncm91cGVkQ29sdW1uczogdW5ncm91cGVkQ29sc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25Hcm91cGluZ0RvbmUuZW1pdChncm91cGluZ0RvbmVBcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZ3JvdXBpbmdFeHByZXNzaW9uc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SUdyb3VwaW5nRXhwcmVzc2lvbltdPigpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIGEgbGlzdCBvZiBleHBhbnNpb24gc3RhdGVzIGZvciBncm91cCByb3dzLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSW5jbHVkZXMgb25seSBzdGF0ZXMgdGhhdCBkaWZmZXIgZnJvbSB0aGUgZGVmYXVsdCBvbmUgKGNvbnRyb2xsZWQgdGhyb3VnaCBncm91cHNFeHBhbmRlZCBhbmQgc3RhdGVzIHRoYXQgdGhlIHVzZXIgaGFzIGNoYW5nZWQuXG4gICAgICogQ29udGFpbnMgdGhlIGV4cGFuc2lvbiBzdGF0ZSAoZXhwYW5kZWQ6IGJvb2xlYW4pIGFuZCB0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cCByb3cgKEFycmF5KS5cbiAgICAgKiBTdXBwb3J0cyB0d28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiIFsoZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSldPVwibW9kZWwuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwaW5nRXhwYW5kU3RhdGU7XG4gICAgfVxuXG4gICAgc2V0IGdyb3VwaW5nRXhwYW5zaW9uU3RhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9ncm91cGluZ0V4cGFuZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5ncmlkQVBJLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdyb3VwaW5nRXhwYW5zaW9uU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElHcm91cEJ5RXhwYW5kU3RhdGVbXT4oKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIGNyZWF0ZWQgZ3JvdXBzIGFyZSByZW5kZXJlZCBleHBhbmRlZCBvciBjb2xsYXBzZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlZCBzdGF0ZSBpcyBleHBhbmRlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFtncm91cHNFeHBhbmRlZF09XCJmYWxzZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ3JvdXBzRXhwYW5kZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGllcmFyY2hpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncm91cCBieSByZWNvcmRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncm91cFJlY29yZHMgPSB0aGlzLmdyaWQuZ3JvdXBzUmVjb3JkcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBzUmVjb3JkczogSUdyb3VwQnlSZWNvcmRbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIGdyb3VwZWQgY29sdW1ucyBzaG91bGQgYmUgaGlkZGVuLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCJmYWxzZVwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtoaWRlR3JvdXBlZENvbHVtbnNdPVwidHJ1ZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGhpZGVHcm91cGVkQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGVHcm91cGVkQ29sdW1ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGhpZGVHcm91cGVkQ29sdW1ucyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdEaWZmZXIgPSB0aGlzLmRpZmZlcnMuZmluZCh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpLmNyZWF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0RpZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGlzdCAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEdyb3VwQ29sc1Zpc2liaWxpdHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlkZUdyb3VwZWRDb2x1bW5zID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBtZXNzYWdlIGRpc3BsYXllZCBpbnNpZGUgdGhlIEdyb3VwQnkgZHJvcCBhcmVhIHdoZXJlIGNvbHVtbnMgY2FuIGJlIGRyYWdnZWQgb24uXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZ3JpZCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBncm91cGFibGUgY29sdW1uIGluIG9yZGVyIHRoZSBHcm91cEJ5IGFyZWEgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBkcm9wQXJlYU1lc3NhZ2U9XCJEcm9wIGhlcmUgdG8gZ3JvdXAhXCI+XG4gICAgICogICAgICA8aWd4LWNvbHVtbiBbZ3JvdXBhYmxlXT1cInRydWVcIiBmaWVsZD1cIklEXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgZHJvcEFyZWFNZXNzYWdlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZHJvcEFyZWFNZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBkcm9wQXJlYU1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BBcmVhTWVzc2FnZSB8fCB0aGlzLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9ncm91cEJ5QXJlYV9tZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgR3JvdXBCeSBkcm9wIGFyZWEuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZ3JpZCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBncm91cGFibGUgY29sdW1uIGluIG9yZGVyIHRoZSBHcm91cEJ5IGFyZWEgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbZHJvcEFyZWFUZW1wbGF0ZV09XCJkcm9wQXJlYVJlZlwiPlxuICAgICAqIDwvaWd4LWdyaWQ+XG4gICAgICogPG5nLXRlbXBsYXRlICNteURyb3BBcmVhPlxuICAgICAqICAgICAgPHNwYW4+IEN1c3RvbSBkcm9wIGFyZWEhIDwvc3Bhbj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyb3BBcmVhVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gY29sdW1ucyBhcmUgZ3JvdXBlZC91bmdyb3VwZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgYG9uR3JvdXBpbmdEb25lYCBldmVudCB3b3VsZCBiZSByYWlzZWQgb25seSBvbmNlIGlmIHNldmVyYWwgY29sdW1ucyBnZXQgZ3JvdXBlZCBhdCBvbmNlIGJ5IGNhbGxpbmdcbiAgICAgKiB0aGUgYGdyb3VwQnkoKWAgb3IgYGNsZWFyR3JvdXBpbmcoKWAgQVBJIG1ldGhvZHMgYW5kIHBhc3NpbmcgYW4gYXJyYXkgYXMgYW4gYXJndW1lbnQuXG4gICAgICogVGhlIGV2ZW50IGFyZ3VtZW50cyBwcm92aWRlIHRoZSBgZXhwcmVzc2lvbnNgLCBgZ3JvdXBlZENvbHVtbnNgIGFuZCBgdW5ncm91cGVkQ29sdW1uc2AgcHJvcGVydGllcywgd2hpY2ggY29udGFpblxuICAgICAqIHRoZSBgSVNvcnRpbmdFeHByZXNzaW9uYCBhbmQgdGhlIGBJZ3hDb2x1bW5Db21wb25lbnRgIHJlbGF0ZWQgdG8gdGhlIGdyb3VwaW5nL3VuZ3JvdXBpbmcgb3BlcmF0aW9uLlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgYGdyb3VwZWRDb2x1bW5zYCBhbmQgYHVuZ3JvdXBlZENvbHVtbnNgIHNob3cgb25seSB0aGUgKipuZXdseSoqIGNoYW5nZWQgY29sdW1ucyAoYWZmZWN0ZWQgYnkgdGhlICoqbGFzdCoqXG4gICAgICogZ3JvdXBpbmcvdW5ncm91cGluZyBvcGVyYXRpb24pLCBub3QgYWxsIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBncm91cGVkL3VuZ3JvdXBlZC5cbiAgICAgKiBjb2x1bW5zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiAob25Hcm91cGluZ0RvbmUpPVwiZ3JvdXBpbmdEb25lKCRldmVudClcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkdyb3VwaW5nRG9uZSA9IG5ldyBFdmVudEVtaXR0ZXI8SUdyb3VwaW5nRG9uZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIGdyb3VwVGVtcGxhdGU6IElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hHcmlkRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4R3JpZERldGFpbFRlbXBsYXRlRGlyZWN0aXZlLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGdyaWREZXRhaWxzVGVtcGxhdGU6IElneEdyaWREZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIEBWaWV3Q2hpbGRyZW4oSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQsIHsgcmVhZDogSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSlcbiAgICBwcml2YXRlIF9ncm91cHNSb3dMaXN0OiBRdWVyeUxpc3Q8SWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0RHJvcEFyZWEnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgZGVmYXVsdERyb3BBcmVhVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIGdyb3VwIHJvd3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBMaXN0ID0gdGhpcy5ncmlkLmdyb3Vwc1Jvd0xpc3Q7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHNSb3dMaXN0KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgUXVlcnlMaXN0PGFueT4oKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNSb3dMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJMaXN0ID0gdGhpcy5fZ3JvdXBzUm93TGlzdC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBudWxsO1xuICAgICAgICB9KS5zb3J0KChpdGVtMSwgaXRlbTIpID0+IGl0ZW0xLmluZGV4IC0gaXRlbTIuaW5kZXgpO1xuICAgICAgICByZXMucmVzZXQockxpc3QpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZ3JvdXBBcmVhJylcbiAgICBwdWJsaWMgZ3JvdXBBcmVhOiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncmVjb3JkX3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHJlY29yZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZCgnZGV0YWlsX3RlbXBsYXRlX2NvbnRhaW5lcicsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByb3RlY3RlZCBkZXRhaWxUZW1wbGF0ZUNvbnRhaW5lcjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hHcmlkRGV0YWlsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgZGV0YWlsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gPSBudWxsO1xuXG4gICAgQFZpZXdDaGlsZCgnZ3JvdXBfdGVtcGxhdGUnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwcm90ZWN0ZWQgZGVmYXVsdEdyb3VwVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAVmlld0NoaWxkKCdzdW1tYXJ5X3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHN1bW1hcnlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldERldGFpbHNDb250ZXh0KHJvd0RhdGEsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHJvd0RhdGEsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFja0NoYW5nZXMoaW5kZXgsIHJlYykge1xuICAgICAgICBpZiAocmVjLmRldGFpbHNEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWMuZGV0YWlsc0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkZXRhaWxzVmlld0ZvY3VzZWQoY29udGFpbmVyLCByb3dJbmRleCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24uYWN0aXZlTm9kZSA/IHRoaXMubmF2aWdhdGlvbi5hY3RpdmVOb2RlLnJvdyA9IHJvd0luZGV4IDpcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5hY3RpdmVOb2RlID0ge3Jvdzogcm93SW5kZXh9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNEZXRhaWxzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyaWREZXRhaWxzVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Um93VGVtcGxhdGUocm93RGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0dyb3VwQnlSZWNvcmQocm93RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRHcm91cFRlbXBsYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdW1tYXJ5Um93KHJvd0RhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdW1tYXJ5VGVtcGxhdGU7XG4gICAgICAgIH0gIGVsc2UgaWYgKHRoaXMuaGFzRGV0YWlscyAmJiB0aGlzLmlzRGV0YWlsUmVjb3JkKHJvd0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsVGVtcGxhdGVDb250YWluZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGlzRGV0YWlsUmVjb3JkKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkLmRldGFpbHNEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNEZXRhaWxBY3RpdmUocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbi5hY3RpdmVOb2RlID8gdGhpcy5uYXZpZ2F0aW9uLmFjdGl2ZU5vZGUucm93ID09PSByb3dJbmRleCA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBncm91cEFyZWFIb3N0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50RGVuc2l0eUNsYXNzKCdpZ3gtZHJvcC1hcmVhJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2UgZm9yIHRoZSBncm91cCByb3cuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBncm91cFJvd1RlbXBsYXRlID0gdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGU7XG4gICAgICogdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGUgPSBteVJvd1RlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBncm91cFJvd1RlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBSb3dUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBzZXQgZ3JvdXBSb3dUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICB0aGlzLl9ncm91cFJvd1RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2Ugb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCdzIGdyb3VwIGFyZWEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBBcmVhVGVtcGxhdGUgPSB0aGlzLmdyaWQuZ3JvdXBBcmVhVGVtcGxhdGU7XG4gICAgICogdGhpcy5ncmlkLmdyb3VwQXJlYVRlbXBsYXRlID0gbXlBcmVhVGVtcGxhdGUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGdyb3VwQXJlYVRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBBcmVhVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc2V0IGdyb3VwQXJlYVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwQXJlYVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBieSBhIG5ldyBgSWd4Q29sdW1uQ29tcG9uZW50YCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZXhwcmVzc2lvbiwgb3IgbW9kaWZpZXMgYW4gZXhpc3Rpbmcgb25lLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQWxzbyBhbGxvd3MgZm9yIG11bHRpcGxlIGNvbHVtbnMgdG8gYmUgZ3JvdXBlZCBhdCBvbmNlIGlmIGFuIGFycmF5IG9mIGBJU29ydGluZ0V4cHJlc3Npb25gIGlzIHBhc3NlZC5cbiAgICAgKiBUaGUgb25Hcm91cGluZ0RvbmUgZXZlbnQgd291bGQgZ2V0IHJhaXNlZCBvbmx5ICoqb25jZSoqIGlmIHRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5ncm91cEJ5KHsgZmllbGROYW1lOiBuYW1lLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9KTtcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBCeShbXG4gICAgICogICAgIHsgZmllbGROYW1lOiBuYW1lMSwgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkFzYywgaWdub3JlQ2FzZTogZmFsc2UgfSxcbiAgICAgKiAgICAgeyBmaWVsZE5hbWU6IG5hbWUyLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uRGVzYywgaWdub3JlQ2FzZTogdHJ1ZSB9LFxuICAgICAqICAgICB7IGZpZWxkTmFtZTogbmFtZTMsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5EZXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9XG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwQnkoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbiB8IEFycmF5PElHcm91cGluZ0V4cHJlc3Npb24+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSWZOb0NvbHVtbkZpZWxkKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRFZGl0KHRydWUpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfbXVsdGlwbGUoZXhwcmVzc2lvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnkoZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBncm91cGluZyBmb3IgcGFydGljdWxhciBjb2x1bW4sIGFycmF5IG9mIGNvbHVtbnMgb3IgYWxsIGNvbHVtbnMuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDbGVhcnMgYWxsIGdyb3VwaW5nIGluIHRoZSBncmlkLCBpZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxuICAgICAqIElmIGEgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBjbGVhcnMgZ3JvdXBpbmcgZm9yIGEgcGFydGljdWxhciBjb2x1bW4gb3IgYW4gYXJyYXkgb2YgY29sdW1ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZygpOyAvL2NsZWFycyBhbGwgZ3JvdXBpbmdcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZyhcIklEXCIpOyAvL3VuZ3JvdXBzIGEgc2luZ2xlIGNvbHVtblxuICAgICAqIHRoaXMuZ3JpZC5jbGVhckdyb3VwaW5nKFtcIklEXCIsIFwiQ29sdW1uMVwiLCBcIkNvbHVtbjJcIl0pOyAvL3VuZ3JvdXBzIG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIGNvbHVtbiBvciBhcnJheSBvZiBjb2x1bW4gbmFtZXMgdG8gYmUgdW5ncm91cGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhckdyb3VwaW5nKG5hbWU/OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuY2xlYXJfZ3JvdXBieShuYW1lKTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBwcmV2ZW50SGVhZGVyU2Nyb2xsKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MudGFyZ2V0LnNjcm9sbExlZnQgIT09IDApIHtcbiAgICAgICAgICAgICh0aGlzLm5hdmlnYXRpb24gYXMgYW55KS5mb3JPZkRpcigpLmdldFNjcm9sbCgpLnNjcm9sbExlZnQgPSAgYXJncy50YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIGFyZ3MudGFyZ2V0LnNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBhIGdyb3VwIGlzIGV4cGFuZGVkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIHJlY29yZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkO1xuICAgICAqIGNvbnN0IGV4cGFuZGVkR3JvdXAgPSB0aGlzLmdyaWQuaXNFeHBhbmRlZEdyb3VwKHRoaXMuZ3JvdXBSb3cpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0V4cGFuZGVkR3JvdXAoZ3JvdXA6IElHcm91cEJ5UmVjb3JkKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHN0YXRlOiBJR3JvdXBCeUV4cGFuZFN0YXRlID0gdGhpcy5fZ2V0U3RhdGVGb3JHcm91cFJvdyhncm91cCk7XG4gICAgICAgIHJldHVybiBzdGF0ZSA/IHN0YXRlLmV4cGFuZGVkIDogdGhpcy5ncm91cHNFeHBhbmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgYSBncm91cC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBSb3cgVGhlIGdyb3VwIHJlY29yZCB0byB0b2dnbGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcbiAgICAgKiBjb25zdCB0b2dnbGVFeHBHcm91cCA9IHRoaXMuZ3JpZC50b2dnbGVHcm91cCh0aGlzLmdyb3VwUm93KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlR3JvdXAoZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUdyb3VwKGdyb3VwUm93KTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgc3BlY2lmaWVkIGdyb3VwIGFuZCBhbGwgb2YgaXRzIHBhcmVudCBncm91cHMuXG4gICAgICogQHBhcmFtIGdyb3VwUm93IFRoZSBncm91cCByZWNvcmQgdG8gZnVsbHkgZXhwYW5kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogdGhpcy5ncmlkLmZ1bGx5RXhwYW5kR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGZ1bGx5RXhwYW5kR3JvdXAoZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkKSB7XG4gICAgICAgIHRoaXMuX2Z1bGx5RXhwYW5kR3JvdXAoZ3JvdXBSb3cpO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0dyb3VwQnlSZWNvcmQocmVjb3JkOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgLy8gcmV0dXJuIHJlY29yZC5yZWNvcmRzIGluc3RhbmNlIG9mIEdyb3VwZWRSZWNvcmRzIGZhaWxzIHVuZGVyIFdlYnBhY2tcbiAgICAgICAgcmV0dXJuIHJlY29yZC5yZWNvcmRzICYmIHJlY29yZC5yZWNvcmRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgYWxsIGdyb3VwIHJvd3MgcmVjdXJzaXZlbHkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnRvZ2dsZUFsbEdyb3VwUm93cztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlQWxsR3JvdXBSb3dzKCkge1xuICAgICAgICB0aGlzLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGUgPSBbXTtcbiAgICAgICAgdGhpcy5ncm91cHNFeHBhbmRlZCA9ICF0aGlzLmdyb3Vwc0V4cGFuZGVkO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIGdyb3VwYWJsZSBjb2x1bW5zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwYWJsZUdyaWQgPSB0aGlzLmdyaWQuaGFzR3JvdXBhYmxlQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaGFzR3JvdXBhYmxlQ29sdW1ucygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTGlzdC5zb21lKChjb2wpID0+IGNvbC5ncm91cGFibGUgJiYgIWNvbC5jb2x1bW5Hcm91cCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2V0R3JvdXBDb2xzVmlzaWJpbGl0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5MaXN0Lmxlbmd0aCA+IDAgJiYgIXRoaXMuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmZvckVhY2goKGV4cHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoZSBncmlkJ3MgZ3JvdXAgYnkgZHJvcCBhcmVhIGlzIHZpc2libGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZHJvcFZpc2libGUgPSB0aGlzLmdyaWQuZHJvcEFyZWFWaXNpYmxlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZHJvcEFyZWFWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuZHJhZ2dlZENvbHVtbiAmJiB0aGlzLmRyYWdnZWRDb2x1bW4uZ3JvdXBhYmxlKSB8fFxuICAgICAgICAgICAgIXRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCk6IElHcm91cEJ5RXhwYW5kU3RhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X2dldF9leHBhbmRlZF9mb3JfZ3JvdXAoZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3RvZ2dsZUdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfdG9nZ2xlX2dyb3VwKGdyb3VwUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZnVsbHlFeHBhbmRHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X2Z1bGx5X2V4cGFuZF9ncm91cChncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FwcGx5R3JvdXBpbmcoKSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuc29ydF9tdWx0aXBsZSh0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NvbHVtbkdyb3VwZWQoZmllbGROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5maW5kKGV4cCA9PiBleHAuZmllbGROYW1lID09PSBmaWVsZE5hbWUpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldENvbnRleHQocm93RGF0YTogYW55LCByb3dJbmRleDogbnVtYmVyLCBwaW5uZWQ/OiBib29sZWFuKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZXRhaWxSZWNvcmQocm93RGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNoaWxkRGV0YWlsVGVtcGxhdGVzLmdldChyb3dEYXRhLmRldGFpbHNEYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd0lEID0gdGhpcy5wcmltYXJ5S2V5ID8gcm93RGF0YS5kZXRhaWxzRGF0YVt0aGlzLnByaW1hcnlLZXldIDogdGhpcy5kYXRhLmluZGV4T2Yocm93RGF0YS5kZXRhaWxzRGF0YSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjYWNoZWREYXRhLnZpZXc7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1scE91dGxldCA9IGNhY2hlZERhdGEub3duZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiByb3dEYXRhLmRldGFpbHNEYXRhLFxuICAgICAgICAgICAgICAgICAgICBtb3ZlVmlldzogdmlldyxcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRtbHBPdXRsZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmRhdGFWaWV3LmluZGV4T2Yocm93RGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlSUQ6ICdkZXRhaWxSb3ctJyArIHJvd0lEXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgcm93cyBjb250YWluIHVuaXF1ZSBncmlkcywgaGVuY2Ugc2hvdWxkIGhhdmUgdW5pcXVlIHRlbXBsYXRlc1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRpbXBsaWNpdDogcm93RGF0YS5kZXRhaWxzRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVJRDogJ2RldGFpbFJvdy0nICsgcm93SUQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmRhdGFWaWV3LmluZGV4T2Yocm93RGF0YSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHRoaXMuaXNHaG9zdFJlY29yZChyb3dEYXRhKSA/IHJvd0RhdGEucmVjb3JkUmVmIDogcm93RGF0YSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldERhdGFWaWV3SW5kZXgocm93SW5kZXgsIHBpbm5lZCksXG4gICAgICAgICAgICB0ZW1wbGF0ZUlEOiB0aGlzLmlzR3JvdXBCeVJlY29yZChyb3dEYXRhKSA/ICdncm91cFJvdycgOiB0aGlzLmlzU3VtbWFyeVJvdyhyb3dEYXRhKSA/ICdzdW1tYXJ5Um93JyA6ICdkYXRhUm93JyxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmlzR2hvc3RSZWNvcmQocm93RGF0YSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB2aWV3Q3JlYXRlZEhhbmRsZXIoYXJncykge1xuICAgICAgICBpZiAoYXJncy5jb250ZXh0LnRlbXBsYXRlSUQuaW5kZXhPZignZGV0YWlsUm93JykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkRGV0YWlsVGVtcGxhdGVzLnNldChhcmdzLmNvbnRleHQuJGltcGxpY2l0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHZpZXdNb3ZlZEhhbmRsZXIoYXJncykge1xuICAgICAgICBpZiAoYXJncy5jb250ZXh0LnRlbXBsYXRlSUQuaW5kZXhPZignZGV0YWlsUm93JykgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyB2aWV3IHdhcyBtb3ZlZCwgdXBkYXRlIG93bmVyIGluIGNhY2hlXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzLmNvbnRleHQuJGltcGxpY2l0O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuY2hpbGREZXRhaWxUZW1wbGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBjYWNoZWREYXRhLm93bmVyID0gYXJncy5vd25lcjtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZERhdGEgJiYgdGhpcy5maWx0ZXJlZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA/IHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgOiB0aGlzLmVtcHR5RmlsdGVyZWRHcmlkVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcgJiYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhTGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZ0dyaWRUZW1wbGF0ZSA/IHRoaXMubG9hZGluZ0dyaWRUZW1wbGF0ZSA6IHRoaXMubG9hZGluZ0dyaWREZWZhdWx0VGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA/IHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgOiB0aGlzLmVtcHR5R3JpZERlZmF1bHRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcFJlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICB0aGlzLmNsZWFyR3JvdXBpbmcoZXZlbnQub3duZXIuaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGNoaXBzT3JkZXJDaGFuZ2VkKGV2ZW50OiBJQ2hpcHNBcmVhUmVvcmRlckV2ZW50QXJncykge1xuICAgICAgICBjb25zdCBuZXdHcm91cGluZyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmNoaXBzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZmllbGROYW1lID09PSBldmVudC5jaGlwc0FycmF5W2ldLmlkO1xuICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpLmdyb3VwYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIGRpc2FsbG93IGNoYW5naW5nIG9yZGVyIGlmIHRoZXJlIGFyZSBjb2x1bW5zIHdpdGggZ3JvdXBhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0dyb3VwaW5nLnB1c2goZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW107XG4gICAgICAgIHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnMgPSBuZXdHcm91cGluZztcblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcmVvcmRlcmVkIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24sIHdlIGRvbid0IGhhdmUgYG9uTW92ZUVuZGAgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgPSB0aGlzLmNoaXBzR291cGluZ0V4cHJlc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGNoaXBzTW92aW5nRW5kZWQoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcENsaWNrZWQoZXZlbnQ6IElDaGlwQ2xpY2tFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc29ydGluZ0V4cHIgPSB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucztcbiAgICAgICAgY29uc3QgY29sdW1uRXhwciA9IHNvcnRpbmdFeHByLmZpbmQoKGV4cHIpID0+IGV4cHIuZmllbGROYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIGNvbHVtbkV4cHIuZGlyID0gMyAtIGNvbHVtbkV4cHIuZGlyO1xuICAgICAgICB0aGlzLnNvcnQoY29sdW1uRXhwcik7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcEtleURvd24oZXZlbnQ6IElDaGlwS2V5RG93bkV2ZW50QXJncykge1xuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5rZXkgPT09ICcgJyB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmtleSA9PT0gJ1NwYWNlYmFyJyB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgY29uc3Qgc29ydGluZ0V4cHIgPSB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucztcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkV4cHIgPSBzb3J0aW5nRXhwci5maW5kKChleHByKSA9PiBleHByLmZpZWxkTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICAgICAgY29sdW1uRXhwci5kaXIgPSAzIC0gY29sdW1uRXhwci5kaXI7XG4gICAgICAgICAgICB0aGlzLnNvcnQoY29sdW1uRXhwcik7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldCBkZWZhdWx0VGFyZ2V0Qm9keUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhbGxJdGVtcyA9IHRoaXMudG90YWxJdGVtQ291bnQgfHwgdGhpcy5kYXRhTGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZFJvd0hlaWdodCAqIE1hdGgubWluKHRoaXMuX2RlZmF1bHRUYXJnZXRSZWNvcmROdW1iZXIsXG4gICAgICAgICAgICB0aGlzLnBhZ2luZyA/IE1hdGgubWluKGFsbEl0ZW1zLCB0aGlzLnBlclBhZ2UpIDogYWxsSXRlbXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEdyb3VwQXJlYUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEFyZWEgPyB0aGlzLmdyb3VwQXJlYS5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocm93OiBhbnkgfCBudW1iZXIsIGNvbHVtbjogYW55IHwgbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aFxuICAgICAgICAgICAgJiYgdHlwZW9mKHJvdykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCByb3dJbmRleCA9IHRoaXMuZ3JvdXBpbmdSZXN1bHQuaW5kZXhPZihyb3cpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBCeVJlY29yZCA9IHRoaXMuZ3JvdXBpbmdNZXRhZGF0YVtyb3dJbmRleF07XG4gICAgICAgICAgICBpZiAoZ3JvdXBCeVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGx5RXhwYW5kR3JvdXAoZ3JvdXBCeVJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5zY3JvbGxUbyhyb3csIGNvbHVtbiwgdGhpcy5ncm91cGluZ0ZsYXRSZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBkcm9wQXJlYVRlbXBsYXRlUmVzb2x2ZWQoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BBcmVhVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BBcmVhVGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RHJvcEFyZWFUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldEdyb3VwQnlDaGlwVGl0bGUoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGV4cHJlc3Npb24uZmllbGROYW1lKTtcbiAgICAgICAgcmV0dXJuIChjb2x1bW4gJiYgY29sdW1uLmhlYWRlcikgfHwgZXhwcmVzc2lvbi5maWVsZE5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBpY29uVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc0V4cGFuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJFeHBhbmRJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRFeHBhbmRlZFRlbXBsYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyQ29sbGFwc2VJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRDb2xsYXBzZWRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldENvbHVtbkdyb3VwYWJsZShmaWVsZE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkJ5TmFtZShmaWVsZE5hbWUpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5ncm91cGFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dGaWx0ZXJpbmcgJiYgdGhpcy5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlck1vZGUgPSBGaWx0ZXJNb2RlLmV4Y2VsU3R5bGVGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBSb3dUZW1wbGF0ZSA9IHRoaXMuZ3JvdXBUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhpZGVHcm91cGVkQ29sdW1ucyAmJiB0aGlzLmNvbHVtbkxpc3QgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHRoaXMuaGlkZUdyb3VwZWRDb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR1cE5hdmlnYXRpb25TZXJ2aWNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5vbkJlZm9yZVZpZXdEZXN0cm95ZWQucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgodmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93RGF0YSA9IHZpZXcuY29udGV4dC4kaW1wbGljaXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RldGFpbFJlY29yZChyb3dEYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNoaWxkRGV0YWlsVGVtcGxhdGVzLmdldChyb3dEYXRhLmRldGFpbHNEYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bWxwT3V0bGV0ID0gY2FjaGVkRGF0YS5vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgdG1scE91dGxldC5fdmlld0NvbnRhaW5lclJlZi5kZXRhY2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5vbkdyb3VwaW5nRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZEVkaXQodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLnVwZGF0ZVN1bW1hcnlDYWNoZShhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlckZlYXR1cmVzV2lkdGggPSBOYU47XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdEaWZmZXIgJiYgdGhpcy5jb2x1bW5MaXN0ICYmICF0aGlzLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmdyb3VwaW5nRGlmZmVyLmRpZmYodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYmIHRoaXMuY29sdW1uTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZERhdGEoZm9ybWF0dGVycyA9IGZhbHNlLCBoZWFkZXJzID0gZmFsc2UpOiBhbnlbXSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoIHx8IHRoaXMuaGFzRGV0YWlscykge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSAocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5leHByZXNzaW9uIHx8IHJlY29yZC5zdW1tYXJpZXMgfHwgdGhpcy5pc0RldGFpbFJlY29yZChyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvdXJjZS5wdXNoKHJlY29yZCk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVZpZXcuZm9yRWFjaChwcm9jZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3REYXRhRnJvbVNlbGVjdGlvbihzb3VyY2UsIGZvcm1hdHRlcnMsIGhlYWRlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldFNlbGVjdGVkRGF0YShmb3JtYXR0ZXJzLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX3NldHVwTmF2aWdhdGlvblNlcnZpY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5ldyBJZ3hHcmlkTVJMTmF2aWdhdGlvblNlcnZpY2UoKTtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5ncmlkID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tJZk5vQ29sdW1uRmllbGQoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbiB8IEFycmF5PElHcm91cGluZ0V4cHJlc3Npb24+IHwgYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2luZ2xlRXhwcmVzc2lvbiBvZiBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaW5nbGVFeHByZXNzaW9uLmZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFleHByZXNzaW9uLmZpZWxkTmFtZTtcbiAgICB9XG5cbn1cbiJdfQ==