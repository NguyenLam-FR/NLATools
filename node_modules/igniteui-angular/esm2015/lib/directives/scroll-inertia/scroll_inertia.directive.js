import { __decorate } from "tslib";
import { Directive, Input, ElementRef, NgZone, OnInit, NgModule, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
/**
 * @hidden
 */
let IgxScrollInertiaDirective = class IgxScrollInertiaDirective {
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
        this.baseDeltaMultiplier = 1 / 120;
        this.firefoxDeltaMultiplier = 1 / 30;
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            const targetElem = this.parentElement;
            targetElem.addEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.addEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.addEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.addEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.addEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.addEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.addEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.addEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        let scrollDeltaX;
        let scrollDeltaY;
        const scrollStep = this.wheelStep;
        const minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);
        }
        /** Get delta for the Y axis */
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            const curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt, true);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    preventParentScroll(evt, preventDefault) {
        const curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    onTouchStart(event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    onTouchMove(event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touch = event.touches[0];
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        let scrolledXY; // Object: {x, y}
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    onTouchEnd(event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        let speedX = 0;
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     */
    onPointerDown(event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.parentElement;
        }
        this._gestureObject.addPointer(this._pointer);
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     */
    onPointerUp(event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    }
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     */
    onMSGestureStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    }
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     */
    onMSGestureChange(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touchPos = event, destX = this._startX + this._touchStartX - touchPos.screenX, destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    }
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    _scrollTo(destX, destY) {
        const curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        const curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // TODO Trigger scrolling event?
        const scrolledX = this._scrollToX(destX);
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
    _inertiaInit(speedX, speedY) {
        const stepModifer = this.inertiaStep, inertiaDuration = this.inertiaDuration;
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            const targetElem = this.parentElement;
            targetElem.removeEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.removeEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.removeEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.removeEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.removeEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.removeEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.removeEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.removeEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
};
IgxScrollInertiaDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "IgxScrollInertiaDirection", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "IgxScrollInertiaScrollContainer", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "wheelStep", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaStep", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "swipeToleranceX", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaDeltaY", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaDeltaX", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaDuration", void 0);
IgxScrollInertiaDirective = __decorate([
    Directive({ selector: '[igxScrollInertia]' })
], IgxScrollInertiaDirective);
export { IgxScrollInertiaDirective };
/**
 * @hidden
 */
let IgxScrollInertiaModule = class IgxScrollInertiaModule {
};
IgxScrollInertiaModule = __decorate([
    NgModule({
        declarations: [IgxScrollInertiaDirective],
        exports: [IgxScrollInertiaDirective],
        imports: [CommonModule]
    })
], IgxScrollInertiaModule);
export { IgxScrollInertiaModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsX2luZXJ0aWEuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kaXJlY3RpdmVzL3Njcm9sbC1pbmVydGlhL3Njcm9sbF9pbmVydGlhLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0M7O0dBRUc7QUFFSCxJQUFhLHlCQUF5QixHQUF0QyxNQUFhLHlCQUF5QjtJQUVsQyxZQUFvQixPQUFtQixFQUFVLEtBQWE7UUFBMUMsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFVLFVBQUssR0FBTCxLQUFLLENBQVE7UUFXdkQsY0FBUyxHQUFHLEVBQUUsQ0FBQztRQUdmLGdCQUFXLEdBQUcsR0FBRyxDQUFDO1FBR2xCLG9CQUFlLEdBQUcsRUFBRSxDQUFDO1FBR3JCLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBR2xCLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBR2xCLG9CQUFlLEdBQUcsR0FBRyxDQUFDO1FBVXJCLGtCQUFhLEdBQUcsRUFBRSxDQUFDO1FBU25CLDJCQUFzQixHQUFHLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLFVBQVUsQ0FBQyxDQUFDO1lBQ2pHLHFCQUFxQixDQUFDLENBQUM7WUFDdkIsbUJBQW1CLENBQUM7UUFDWiwrQkFBMEIsR0FBRyxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMseUJBQXlCLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQztZQUN6Ryx5QkFBeUIsQ0FBQyxDQUFDO1lBQzNCLHVCQUF1QixDQUFDO1FBS2hCLHdCQUFtQixHQUFHLENBQUMsR0FBRyxH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QUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25ELENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUVKLENBQUE7O1lBMWVnQyxVQUFVO1lBQWlCLE1BQU07O0FBSzlEO0lBREMsS0FBSyxFQUFFOzRFQUNpQztBQUd6QztJQURDLEtBQUssRUFBRTtrRkFDb0M7QUFHNUM7SUFEQyxLQUFLLEVBQUU7NERBQ2M7QUFHdEI7SUFEQyxLQUFLLEVBQUU7OERBQ2lCO0FBR3pCO0lBREMsS0FBSyxFQUFFO2tFQUNvQjtBQUc1QjtJQURDLEtBQUssRUFBRTtnRUFDaUI7QUFHekI7SUFEQyxLQUFLLEVBQUU7Z0VBQ2lCO0FBR3pCO0lBREMsS0FBSyxFQUFFO2tFQUNxQjtBQTVCcEIseUJBQXlCO0lBRHJDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxvQkFBb0IsRUFBRSxDQUFDO0dBQ2pDLHlCQUF5QixDQTRlckM7U0E1ZVkseUJBQXlCO0FBOGV0Qzs7R0FFRztBQU9ILElBQWEsc0JBQXNCLEdBQW5DLE1BQWEsc0JBQXNCO0NBQ2xDLENBQUE7QUFEWSxzQkFBc0I7SUFObEMsUUFBUSxDQUFDO1FBQ04sWUFBWSxFQUFFLENBQUMseUJBQXlCLENBQUM7UUFDekMsT0FBTyxFQUFFLENBQUMseUJBQXlCLENBQUM7UUFDcEMsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDO0tBQzFCLENBQUM7R0FFVyxzQkFBc0IsQ0FDbEM7U0FEWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmLCBOZ1pvbmUsIE9uSW5pdCwgTmdNb2R1bGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tpZ3hTY3JvbGxJbmVydGlhXScgfSlcbmV4cG9ydCBjbGFzcyBJZ3hTY3JvbGxJbmVydGlhRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcblxuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIElneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb246IHN0cmluZztcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIElneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXI6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHdoZWVsU3RlcCA9IDUwO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5lcnRpYVN0ZXAgPSAxLjU7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzd2lwZVRvbGVyYW5jZVggPSAyMDtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZXJ0aWFEZWx0YVkgPSAzO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5lcnRpYURlbHRhWCA9IDI7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmVydGlhRHVyYXRpb24gPSAwLjU7XG5cbiAgICBwcml2YXRlIF90b3VjaEluZXJ0aWFBbmltSUQ7XG4gICAgcHJpdmF0ZSBfc3RhcnRYO1xuICAgIHByaXZhdGUgX3N0YXJ0WTtcbiAgICBwcml2YXRlIF90b3VjaFN0YXJ0WDtcbiAgICBwcml2YXRlIF90b3VjaFN0YXJ0WTtcbiAgICBwcml2YXRlIF9sYXN0VG91Y2hFbmQ7XG4gICAgcHJpdmF0ZSBfbGFzdFRvdWNoWDtcbiAgICBwcml2YXRlIF9sYXN0VG91Y2hZO1xuICAgIHByaXZhdGUgX3NhdmVkU3BlZWRzWCA9IFtdO1xuICAgIHByaXZhdGUgX3NhdmVkU3BlZWRzWTtcbiAgICBwcml2YXRlIF90b3RhbE1vdmVkWDtcbiAgICBwcml2YXRlIF9vZmZzZXRSZWNvcmRlZDtcbiAgICBwcml2YXRlIF9vZmZzZXREaXJlY3Rpb247XG4gICAgcHJpdmF0ZSBfdG91Y2hQcmV2ZW50ZWQ7XG4gICAgcHJpdmF0ZSBfbGFzdE1vdmVkWDtcbiAgICBwcml2YXRlIF9sYXN0TW92ZWRZO1xuICAgIHByaXZhdGUgX2dlc3R1cmVPYmplY3Q7XG4gICAgcHJpdmF0ZSBzZXRQb2ludGVyQ2FwdHVyZUZOYW1lID0gdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlWydtc1NldFBvaW50ZXJDYXB0dXJlJ10gPT09ICdmdW5jdGlvbicgP1xuICAgICdtc1NldFBvaW50ZXJDYXB0dXJlJyA6XG4gICAgJ3NldFBvaW50ZXJDYXB0dXJlJztcbiAgICBwcml2YXRlIHJlbGVhc2VQb2ludGVyQ2FwdHVyZUZOYW1lID0gdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlWydtc1JlbGVhc2VQb2ludGVyQ2FwdHVyZSddID09PSAnZnVuY3Rpb24nID9cbiAgICAnbXNSZWxlYXNlUG9pbnRlckNhcHR1cmUnIDpcbiAgICAncmVsZWFzZVBvaW50ZXJDYXB0dXJlJztcbiAgICBwcml2YXRlIF9wb2ludGVyO1xuICAgIHByaXZhdGUgX25leHRYO1xuICAgIHByaXZhdGUgX25leHRZO1xuICAgIHByaXZhdGUgcGFyZW50RWxlbWVudDtcbiAgICBwcml2YXRlIGJhc2VEZWx0YU11bHRpcGxpZXIgPSAxIC8gMTIwO1xuICAgIHByaXZhdGUgZmlyZWZveERlbHRhTXVsdGlwbGllciA9IDEgLyAzMDtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW0gPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uV2hlZWwoZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAoZXZ0KSA9PiB7IHRoaXMub25Ub3VjaFN0YXJ0KGV2dCk7IH0pO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAoZXZ0KSA9PiB7IHRoaXMub25Ub3VjaE1vdmUoZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uVG91Y2hFbmQoZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uUG9pbnRlckRvd24oZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsXG4gICAgICAgICAgICAgICAgICAgICAoZXZ0KSA9PiB7IHRoaXMub25Qb2ludGVyVXAoZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZVN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uTVNHZXN0dXJlU3RhcnQoZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgIChldnQpID0+IHsgdGhpcy5vbk1TR2VzdHVyZUNoYW5nZShldnQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gc2Nyb2xsaW5nIHdpdGggdGhlIG1vdXNlIHdoZWVsIG9yIHVzaW5nIHRvdWNocGFkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uV2hlZWwoZXZ0KSB7XG4gICAgICAgIC8vIGlmIG5vIHNjcm9sbGJhciByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsRGVsdGFYO1xuICAgICAgICBsZXQgc2Nyb2xsRGVsdGFZO1xuICAgICAgICBjb25zdCBzY3JvbGxTdGVwID0gdGhpcy53aGVlbFN0ZXA7XG4gICAgICAgIGNvbnN0IG1pbldoZWVsU3RlcCA9IDEgLyB0aGlzLndoZWVsU3RlcDtcblxuICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoZXZ0LndoZWVsRGVsdGFYKSB7XG4gICAgICAgICAgICAvKiBPcHRpb24gc3VwcG9ydGVkIG9uIENocm9tZSwgU2FmYXJpLCBPcGVyYS5cbiAgICAgICAgICAgIC8qIDEyMCBpcyBkZWZhdWx0IGZvciBtb3VzZXdoZWVsIG9uIHRoZXNlIGJyb3dzZXJzLiBPdGhlciB2YWx1ZXMgYXJlIGZvciB0cmFja3BhZHMgKi9cbiAgICAgICAgICAgIHNjcm9sbERlbHRhWCA9IC1ldnQud2hlZWxEZWx0YVggKiB0aGlzLmJhc2VEZWx0YU11bHRpcGxpZXI7XG5cbiAgICAgICAgICAgIGlmICgtbWluV2hlZWxTdGVwIDwgc2Nyb2xsRGVsdGFYICYmIHNjcm9sbERlbHRhWCA8IG1pbldoZWVsU3RlcCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbERlbHRhWCA9IE1hdGguc2lnbihzY3JvbGxEZWx0YVgpICogbWluV2hlZWxTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2dC5kZWx0YVgpIHtcbiAgICAgICAgICAgIC8qIEZvciBvdGhlciBicm93c2VycyB0aGF0IGRvbid0IHByb3ZpZGUgd2hlZWxEZWx0YSwgdXNlIHRoZSBkZWx0YVkgdG8gZGV0ZXJtaW5lIGRpcmVjdGlvbiBhbmQgcGFzcyBkZWZhdWx0IHZhbHVlcy4gKi9cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhU2NhbGVkWCA9IGV2dC5kZWx0YVggKiAoZXZ0LmRlbHRhTW9kZSA9PT0gMCA/ICB0aGlzLmZpcmVmb3hEZWx0YU11bHRpcGxpZXIgOiAxKTtcbiAgICAgICAgICAgIHNjcm9sbERlbHRhWCA9IHRoaXMuY2FsY0F4aXNDb29yZHMoZGVsdGFTY2FsZWRYLCAtMSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogR2V0IGRlbHRhIGZvciB0aGUgWSBheGlzICovXG4gICAgICAgIGlmIChldnQud2hlZWxEZWx0YVkpIHtcbiAgICAgICAgICAgIC8qIE9wdGlvbiBzdXBwb3J0ZWQgb24gQ2hyb21lLCBTYWZhcmksIE9wZXJhLlxuICAgICAgICAgICAgLyogMTIwIGlzIGRlZmF1bHQgZm9yIG1vdXNld2hlZWwgb24gdGhlc2UgYnJvd3NlcnMuIE90aGVyIHZhbHVlcyBhcmUgZm9yIHRyYWNrcGFkcyAqL1xuICAgICAgICAgICAgc2Nyb2xsRGVsdGFZID0gLWV2dC53aGVlbERlbHRhWSAqIHRoaXMuYmFzZURlbHRhTXVsdGlwbGllcjtcblxuICAgICAgICAgICAgaWYgKC1taW5XaGVlbFN0ZXAgPCBzY3JvbGxEZWx0YVkgJiYgc2Nyb2xsRGVsdGFZIDwgbWluV2hlZWxTdGVwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRGVsdGFZID0gTWF0aC5zaWduKHNjcm9sbERlbHRhWSkgKiBtaW5XaGVlbFN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZ0LmRlbHRhWSkge1xuICAgICAgICAgICAgLyogRm9yIG90aGVyIGJyb3dzZXJzIHRoYXQgZG9uJ3QgcHJvdmlkZSB3aGVlbERlbHRhLCB1c2UgdGhlIGRlbHRhWSB0byBkZXRlcm1pbmUgZGlyZWN0aW9uIGFuZCBwYXNzIGRlZmF1bHQgdmFsdWVzLiAqL1xuICAgICAgICAgICAgY29uc3QgZGVsdGFTY2FsZWRZID0gZXZ0LmRlbHRhWSAqIChldnQuZGVsdGFNb2RlID09PSAwID8gIHRoaXMuZmlyZWZveERlbHRhTXVsdGlwbGllciA6IDEpO1xuICAgICAgICAgICAgc2Nyb2xsRGVsdGFZID0gdGhpcy5jYWxjQXhpc0Nvb3JkcyhkZWx0YVNjYWxlZFksIC0xLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsRGVsdGFYICYmIHRoaXMuSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb1goXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYICsgc2Nyb2xsRGVsdGFYICogc2Nyb2xsU3RlcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGN1clNjcm9sbExlZnQgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIGNvbnN0IG1heFNjcm9sbExlZnQgPSBwYXJzZUludCh0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGgsIDEwKTtcbiAgICAgICAgICAgIGlmICgwIDwgY3VyU2Nyb2xsTGVmdCAmJiBjdXJTY3JvbGxMZWZ0IDwgbWF4U2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmF2aWdhdGluZyB0aHJvdWdoIHBhZ2VzIHdoZW4gc2Nyb2xsaW5nIG9uIE1hY1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbERlbHRhWSAmJiB0aGlzLklneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvWShcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgKyBzY3JvbGxEZWx0YVkgKiBzY3JvbGxTdGVwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50UGFyZW50U2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogV2hlbiB0aGVyZSBpcyBzdGlsbCByb29tIHRvIHNjcm9sbCB1cC9kb3duIHByZXZlbnQgdGhlIHBhcmVudCBlbGVtZW50cyBmcm9tIHNjcm9sbGluZyB0b28uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHByZXZlbnRQYXJlbnRTY3JvbGwoZXZ0LCBwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBjb25zdCBjdXJTY3JvbGxUb3AgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBtYXhTY3JvbGxUb3AgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuY2hpbGRyZW5bMF0uc2Nyb2xsSGVpZ2h0IC1cbiAgICAgICAgICAgIHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICgwIDwgY3VyU2Nyb2xsVG9wICYmIGN1clNjcm9sbFRvcCA8IG1heFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2dC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdGhlIGZpcnN0IG1vbWVudCB3ZSBzdGFydCBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb250ZW50IG9uIGEgdG91Y2ggZGV2aWNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wcyBhbnkgY3VycmVudCBvbmdvaW5nIGluZXJ0aWFcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEKTtcblxuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbIDAgXTtcblxuICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcblxuICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHRoaXMuX3RvdWNoU3RhcnRYID0gdG91Y2gucGFnZVg7XG4gICAgICAgIHRoaXMuX3RvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoRW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaFggPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoWSA9IHRvdWNoLnBhZ2VZO1xuICAgICAgICB0aGlzLl9zYXZlZFNwZWVkc1ggPSBbXTtcbiAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNZID0gW107XG5cbiAgICAgICAgLy8gVmFycyByZWdhcmRpbmcgc3dpcGUgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3RvdGFsTW92ZWRYID0gMDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0UmVjb3JkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0RGlyZWN0aW9uID0gMDtcblxuICAgICAgICB0aGlzLl90b3VjaFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5JZ3hTY3JvbGxJbmVydGlhRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRQYXJlbnRTY3JvbGwoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHdlIG5lZWQgdG8gc2Nyb2xsIHRoZSBjb250ZW50IGJhc2VkIG9uIHRvdWNoIGludGVyYWN0aW9uc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBvblRvdWNoTW92ZShldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWyAwIF07XG4gICAgICAgIGNvbnN0IGRlc3RYID0gdGhpcy5fc3RhcnRYICsgKHRoaXMuX3RvdWNoU3RhcnRYIC0gdG91Y2gucGFnZVgpICogTWF0aC5zaWduKHRoaXMuaW5lcnRpYVN0ZXApO1xuICAgICAgICBjb25zdCBkZXN0WSA9IHRoaXMuX3N0YXJ0WSArICh0aGlzLl90b3VjaFN0YXJ0WSAtIHRvdWNoLnBhZ2VZKSAqIE1hdGguc2lnbih0aGlzLmluZXJ0aWFTdGVwKTtcblxuICAgICAgICAvKiBIYW5kbGUgY29tcGxleCB0b3VjaG1vdmVzIHdoZW4gc3dpcGUgc3RvcHMgYnV0IHRoZSB0b2NoIGRvZXNuJ3QgZW5kIGFuZCB0aGVuIGEgc3dpcGUgaXMgaW5pdGlhdGVkIGFnYWluICovXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgICAgICBjb25zdCB0aW1lRnJvbUxhc3RUb3VjaCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLl9sYXN0VG91Y2hFbmQ7XG4gICAgICAgIGlmICh0aW1lRnJvbUxhc3RUb3VjaCAhPT0gMCAmJiB0aW1lRnJvbUxhc3RUb3VjaCA8IDEwMCkge1xuICAgICAgICAgICAgY29uc3Qgc3BlZWRYID0gKHRoaXMuX2xhc3RUb3VjaFggLSB0b3VjaC5wYWdlWCkgLyB0aW1lRnJvbUxhc3RUb3VjaDtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVkWSA9ICh0aGlzLl9sYXN0VG91Y2hZIC0gdG91Y2gucGFnZVkpIC8gdGltZUZyb21MYXN0VG91Y2g7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgNSBzcGVlZHMgYmV0d2VlbiB0d28gdG91Y2htb3ZlcyBvbiBYIGF4aXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFNwZWVkc1gubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWC5wdXNoKHNwZWVkWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWC5wdXNoKHNwZWVkWCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgNSBzcGVlZHMgYmV0d2VlbiB0d28gdG91Y2htb3ZlcyBvbiBZIGF4aXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFNwZWVkc1kubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWS5wdXNoKHNwZWVkWSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWS5wdXNoKHNwZWVkWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoRW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuX2xhc3RNb3ZlZFggPSB0aGlzLl9sYXN0VG91Y2hYIC0gdG91Y2gucGFnZVg7XG4gICAgICAgIHRoaXMuX2xhc3RNb3ZlZFkgPSB0aGlzLl9sYXN0VG91Y2hZIC0gdG91Y2gucGFnZVk7XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaFggPSB0b3VjaC5wYWdlWDtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoWSA9IHRvdWNoLnBhZ2VZO1xuXG4gICAgICAgIHRoaXMuX3RvdGFsTW92ZWRYICs9IHRoaXMuX2xhc3RNb3ZlZFg7XG5cbiAgICAgICAgbGV0IHNjcm9sbGVkWFk7IC8vIE9iamVjdDoge3gsIHl9XG4gICAgICAgIC8qXHREbyBub3Qgc2Nyb2xsIHVzaW5nIHRvdWNoIHVudGlsbCBvdXQgb2YgdGhlIHN3aXBlVG9sZXJhbmNlWCBib3VuZHMgKi9cbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3RvdGFsTW92ZWRYKSA8IHRoaXMuc3dpcGVUb2xlcmFuY2VYICYmICF0aGlzLl9vZmZzZXRSZWNvcmRlZCkge1xuICAgICAgICAgICAgc2Nyb2xsZWRYWSA9IHRoaXMuX3Njcm9sbFRvKHRoaXMuX3N0YXJ0WCwgZGVzdFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLypcdFJlY29yZCB0aGUgZGlyZWN0aW9uIHRoZSBmaXJzdCB0aW1lIHdlIGFyZSBvdXQgb2YgdGhlIHN3aXBlVG9sZXJhbmNlWCBib3VuZHMuXG5cdFx0XHQqXHRUaGF0IHdheSB3ZSBrbm93IHdoaWNoIGRpcmVjdGlvbiB3ZSBhcHBseSB0aGUgb2Zmc2V0IHNvIGl0IGRvZXNuJ3QgaGlja3VwIHdoZW4gbW92aW5nIG91dCBvZiB0aGUgc3dpcGVUb2xlcmFuY2VYIGJvdW5kcyAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9vZmZzZXRSZWNvcmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldERpcmVjdGlvbiA9IE1hdGguc2lnbihkZXN0WCAtIHRoaXMuX3N0YXJ0WCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0UmVjb3JkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlx0U2Nyb2xsIHdpdGggb2Zmc2V0IGFtbW91dCBvZiBzd2lwZVRvbGVyYW5jZVggaW4gdGhlIGRpcmVjdGlvbiB3ZSBoYXZlIGV4aXRlZCB0aGUgYm91bmRzIGFuZFxuICAgICAgICAgICAgZG9uJ3QgY2hhbmdlIGl0IGFmdGVyIHRoYXQgZXZlciB1bnRpbCB0b3VjaGVuZCBhbmQgYWdhaW4gdG91Y2hzdGFydCAqL1xuICAgICAgICAgICAgc2Nyb2xsZWRYWSA9IHRoaXMuX3Njcm9sbFRvKGRlc3RYIC0gdGhpcy5fb2Zmc2V0RGlyZWN0aW9uICogdGhpcy5zd2lwZVRvbGVyYW5jZVgsXG4gICAgICAgICAgICAgICAgZGVzdFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbGVkWFkueCA9PT0gMCAmJiBzY3JvbGxlZFhZLnkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9uIFNhZmFyaSBwcmV2ZW50aW5nIHRoZSB0b3VjaG1vdmUgd291bGQgcHJldmVudCBkZWZhdWx0IHBhZ2Ugc2Nyb2xsIGJlaGF2aW91ciBldmVuIGlmIHRoZXJlIGlzIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBvdmVyZmxvd1xuICAgICAgICBpZiAodGhpcy5JZ3hTY3JvbGxJbmVydGlhRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRQYXJlbnRTY3JvbGwoZXZlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBNU0dlc3R1cmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BlZWRYID0gMDtcbiAgICAgICAgbGV0IHNwZWVkWSA9IDA7XG5cbiAgICAgICAgLy8gc2F2ZWRTcGVlZHNYIGFuZCBzYXZlZFNwZWVkc1kgaGF2ZSBzYW1lIGxlbmd0aFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NhdmVkU3BlZWRzWC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3BlZWRYICs9IHRoaXMuX3NhdmVkU3BlZWRzWFsgaSBdO1xuICAgICAgICAgICAgc3BlZWRZICs9IHRoaXMuX3NhdmVkU3BlZWRzWVsgaSBdO1xuICAgICAgICB9XG4gICAgICAgIHNwZWVkWCA9IHRoaXMuX3NhdmVkU3BlZWRzWC5sZW5ndGggPyBzcGVlZFggLyB0aGlzLl9zYXZlZFNwZWVkc1gubGVuZ3RoIDogMDtcbiAgICAgICAgc3BlZWRZID0gdGhpcy5fc2F2ZWRTcGVlZHNYLmxlbmd0aCA/IHNwZWVkWSAvIHRoaXMuX3NhdmVkU3BlZWRzWS5sZW5ndGggOiAwO1xuXG4gICAgICAgICAvLyBVc2UgdGhlIGxhc3RNb3ZlZFggYW5kIGxhc3RNb3ZlZFkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzd2lwZSBzdG9wcyB3aXRob3V0IGxpZnRpbmcgdGhlIGZpbmdlciBzbyB3ZSBkb24ndCBzdGFydCBpbmVydGlhXG4gICAgICAgIGlmICgoTWF0aC5hYnMoc3BlZWRYKSA+IDAuMSB8fCBNYXRoLmFicyhzcGVlZFkpID4gMC4xKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX2xhc3RNb3ZlZFgpID4gMiB8fCBNYXRoLmFicyh0aGlzLl9sYXN0TW92ZWRZKSA+IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZXJ0aWFJbml0KHNwZWVkWCwgc3BlZWRZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5JZ3hTY3JvbGxJbmVydGlhRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRQYXJlbnRTY3JvbGwoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHdlIG5lZWQgdG8gZGV0ZWN0IHRvdWNoIHN0YXJ0aW5nIG9uIGEgdG91Y2ggZGV2aWNlIG9uIElFL0VkZ2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50IHx8IChldmVudC5wb2ludGVyVHlwZSAhPT0gMiAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykgfHxcbiAgICAgICAgICAgIHR5cGVvZiBNU0dlc3R1cmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0UG9pbnRlckNhcHR1cmVGTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBpcyBzdXBwb3J0ZWRcbiAgICAgICAgZXZlbnQudGFyZ2V0W3RoaXMuc2V0UG9pbnRlckNhcHR1cmVGTmFtZV0odGhpcy5fcG9pbnRlciA9IGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdlc3R1cmVPYmplY3Qgb25seSBvbmUgdGltZSB0byBwcmV2ZW50IG92ZXJsYXBwaW5nIGR1cmluZyBpbnRlcnRpYVxuICAgICAgICBpZiAoIXRoaXMuX2dlc3R1cmVPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVPYmplY3QgPSBuZXcgTVNHZXN0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLl9nZXN0dXJlT2JqZWN0LnRhcmdldCA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nZXN0dXJlT2JqZWN0LmFkZFBvaW50ZXIodGhpcy5fcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gd2UgbmVlZCB0byBkZXRlY3QgdG91Y2ggZW5kaW5nIG9uIGEgdG91Y2ggZGV2aWNlIG9uIElFL0VkZ2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wb2ludGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIHJlbGVhc2VQb2ludGVyQ2FwdHVyZUZOYW1lIGlzIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGlzIHN1cHBvcnRlZCAqL1xuICAgICAgICBldmVudC50YXJnZXRbIHRoaXMucmVsZWFzZVBvaW50ZXJDYXB0dXJlRk5hbWUgXSh0aGlzLl9wb2ludGVyKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5fcG9pbnRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBnZXN0dXJlIGJlZ2lucyBvbiBJRS9FZGdlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uTVNHZXN0dXJlU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcblxuXG4gICAgICAgIHRoaXMuX3RvdWNoU3RhcnRYID0gZXZlbnQuc2NyZWVuWDtcbiAgICAgICAgdGhpcy5fdG91Y2hTdGFydFkgPSBldmVudC5zY3JlZW5ZO1xuXG4gICAgICAgIC8vIFZhcnMgcmVnYXJkaW5nIHN3aXBlIG9mZnNldFxuICAgICAgICB0aGlzLl90b3RhbE1vdmVkWCA9IDA7XG4gICAgICAgIHRoaXMuX29mZnNldFJlY29yZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29mZnNldERpcmVjdGlvbiA9IDA7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHdlIG5lZWQgdG8gc2Nyb2xsIGJhc2VkIG9uIHRoZSBnZXN0dXJlIHBlcmZvcm1lZCBvbiBJRS9FZGdlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uTVNHZXN0dXJlQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG91Y2hQb3MgPSBldmVudCxcbiAgICAgICAgICAgIGRlc3RYID0gdGhpcy5fc3RhcnRYICsgdGhpcy5fdG91Y2hTdGFydFggLSB0b3VjaFBvcy5zY3JlZW5YLFxuICAgICAgICAgICAgZGVzdFkgPSB0aGlzLl9zdGFydFkgKyB0aGlzLl90b3VjaFN0YXJ0WSAtIHRvdWNoUG9zLnNjcmVlblk7XG4gICAgICAgIC8qIExvZ2ljIHJlZ2FyZGluZyB4IHRvbGVyYW5jZSB0byBwcmV2ZW50IGFjY2lkZW50YWwgaG9yaXpvbnRhbCBzY3JvbGxpbmcgd2hlbiBzY3JvbGxpbmcgdmVydGljYWxseSAqL1xuICAgICAgICB0aGlzLl90b3RhbE1vdmVkWCA9IHRoaXMuX3RvdWNoU3RhcnRYIC0gdG91Y2hQb3Muc2NyZWVuWDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3RvdGFsTW92ZWRYKSA8IHRoaXMuc3dpcGVUb2xlcmFuY2VYICYmICF0aGlzLl9vZmZzZXRSZWNvcmRlZCkge1xuICAgICAgICAgICAgLyogRG8gbm90IHNjcm9sbCBob3Jpem9udGFsbHkgeWV0IHdoaWxlIGluIHRoZSB0b2xlcmFuY2UgcmFuZ2UgKi9cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvWShkZXN0WSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29mZnNldFJlY29yZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0RGlyZWN0aW9uID0gTWF0aC5zaWduKGRlc3RYIC0gdGhpcy5fc3RhcnRYKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXRSZWNvcmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBPbmNlIHRoZSB0b2xlcmFuY2UgaXMgZXhjZWVkZWQgaXQgY2FuIGJlIHNjcm9sbGVkIGhvcml6b250YWxseSAqL1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG8oZGVzdFggLSB0aGlzLl9vZmZzZXREaXJlY3Rpb24gKiB0aGlzLnN3aXBlVG9sZXJhbmNlWCwgZGVzdFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FsY0F4aXNDb29yZHModGFyZ2V0LCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0IDwgbWluKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBtaW47XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID4gbWF4KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgX3Njcm9sbFRvKGRlc3RYLCBkZXN0WSkge1xuICAgICAgICBjb25zdCBjdXJQb3NYID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGN1clBvc1kgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAvLyBUT0RPIFRyaWdnZXIgc2Nyb2xsaW5nIGV2ZW50P1xuICAgICAgICBjb25zdCBzY3JvbGxlZFggPSB0aGlzLl9zY3JvbGxUb1goZGVzdFgpO1xuICAgICAgICBjb25zdCBzY3JvbGxlZFkgPSB0aGlzLl9zY3JvbGxUb1koZGVzdFkpO1xuXG4gICAgICAgIHJldHVybiB7IHg6IHNjcm9sbGVkWCwgeTogc2Nyb2xsZWRZIH07XG4gICAgfVxuICAgIHByaXZhdGUgX3Njcm9sbFRvWChkZXN0KSB7XG4gICAgICAgIHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ID0gZGVzdDtcbiAgICB9XG4gICAgcHJpdmF0ZSBfc2Nyb2xsVG9ZKGRlc3QpIHtcbiAgICAgICAgdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IGRlc3Q7XG4gICAgfVxuXG4gICBwcm90ZWN0ZWQgX2luZXJ0aWFJbml0KHNwZWVkWCwgc3BlZWRZKSB7XG4gICAgY29uc3Qgc3RlcE1vZGlmZXIgPSB0aGlzLmluZXJ0aWFTdGVwLFxuICAgICAgICBpbmVydGlhRHVyYXRpb24gPSB0aGlzLmluZXJ0aWFEdXJhdGlvbjtcbiAgICBsZXQgeCA9IDA7XG4gICAgdGhpcy5fbmV4dFggPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICB0aGlzLl9uZXh0WSA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG5cbiAgICAvLyBTZXRzIHRpbWVvdXQgdW50aWwgZXhlY3V0aW5nIG5leHQgbW92ZW1lbnQgaXRlcmF0aW9uIG9mIHRoZSBpbmVydGlhXG4gICAgY29uc3QgaW5lcnRpYVN0ZXAgPSAoKSA9PiB7XG4gICAgICAgIGlmICh4ID4gNikge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNYXRoLmFicyhzcGVlZFgpID4gTWF0aC5hYnMoc3BlZWRZKSkge1xuICAgICAgICAgICAgeCArPSAwLjA1IC8gKDEgKiBpbmVydGlhRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCArPSAwLjA1IC8gKDEgKiBpbmVydGlhRHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPD0gMSkge1xuICAgICAgICAgICAgLy8gV2UgdXNlIGNvbnN0YW50IHF1YXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBvZmZzZXQgd2l0aG91dCBzcGVlZCBmYWxsb2ZmIGJlZm9yIHggcmVhY2hlcyAxXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWRZKSA8PSBNYXRoLmFicyhzcGVlZFgpICogdGhpcy5pbmVydGlhRGVsdGFZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFggKz0gMSAqIHNwZWVkWCAqIDE1ICogc3RlcE1vZGlmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWRZKSA+PSBNYXRoLmFicyhzcGVlZFgpICogdGhpcy5pbmVydGlhRGVsdGFYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFkgKz0gMSAqIHNwZWVkWSAqIDE1ICogc3RlcE1vZGlmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHF1YXRpb24gXCJ5ID0gMiAvICh4ICsgMC41NSkgLSAwLjNcIiB0byBkZXRlcm1pbmUgdGhlIG9mZnNldFxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkWSkgPD0gTWF0aC5hYnMoc3BlZWRYKSAqIHRoaXMuaW5lcnRpYURlbHRhWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRYICs9IE1hdGguYWJzKDIgLyAoeCArIDAuNTUpIC0gMC4zKSAqIHNwZWVkWCAqIDE1ICogc3RlcE1vZGlmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWRZKSA+PSBNYXRoLmFicyhzcGVlZFgpICogdGhpcy5pbmVydGlhRGVsdGFYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFkgKz0gTWF0aC5hYnMoMiAvICh4ICsgMC41NSkgLSAwLjMpICogc3BlZWRZICogMTUgKiBzdGVwTW9kaWZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbWl4ZWQgZW52aXJvbm1lbnQgd2UgdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW91ci4gaS5lLiB0b3VjaHNjcmVlbiArIG1vdXNlXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX25leHRYLCB0aGlzLl9uZXh0WSk7XG5cbiAgICAgICAgdGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGluZXJ0aWFTdGVwKTtcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgaW5lcnRpYSBhbmQgY29udGludWUgaXQgcmVjdXJzaXZlbHlcbiAgICB0aGlzLl90b3VjaEluZXJ0aWFBbmltSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaW5lcnRpYVN0ZXApO1xuICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbSA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRhcmdldEVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLFxuICAgICAgICAgICAgICAgIChldnQpID0+IHsgdGhpcy5vbldoZWVsKGV2dCk7IH0pO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAoZXZ0KSA9PiB7IHRoaXMub25Ub3VjaFN0YXJ0KGV2dCk7IH0pO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgIChldnQpID0+IHsgdGhpcy5vblRvdWNoTW92ZShldnQpOyB9KTtcbiAgICAgICAgICAgIHRhcmdldEVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgIChldnQpID0+IHsgdGhpcy5vblRvdWNoRW5kKGV2dCk7IH0pO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsXG4gICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uUG9pbnRlckRvd24oZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsXG4gICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uUG9pbnRlclVwKGV2dCk7IH0pO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdNU0dlc3R1cmVTdGFydCcsXG4gICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uTVNHZXN0dXJlU3RhcnQoZXZ0KTsgfSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsXG4gICAgICAgICAgICAgICAgKGV2dCkgPT4geyB0aGlzLm9uTVNHZXN0dXJlQ2hhbmdlKGV2dCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneFNjcm9sbEluZXJ0aWFEaXJlY3RpdmVdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4U2Nyb2xsSW5lcnRpYU1vZHVsZSB7XG59XG5cbiJdfQ==