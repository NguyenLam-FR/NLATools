import { IgxSorting, IgxDataRecordSorting } from './sorting-strategy';
import { IgxGrouping } from './grouping-strategy';
import { PagingError } from './paging-state.interface';
import { FilteringStrategy } from './filtering-strategy';
import { cloneValue, mergeObjects } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
import { getHierarchy, isHierarchyMatch } from './operations';
/**
 * @hidden
 */
export var DataType;
(function (DataType) {
    DataType["String"] = "string";
    DataType["Number"] = "number";
    DataType["Boolean"] = "boolean";
    DataType["Date"] = "date";
})(DataType || (DataType = {}));
/**
 * @hidden
 */
export class DataUtil {
    static sort(data, expressions, sorting = new IgxSorting()) {
        return sorting.sort(data, expressions);
    }
    static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent) {
        let res = [];
        hierarchicalData.forEach((hr) => {
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting);
        return res;
    }
    static cloneTreeGridRecord(hierarchicalRecord) {
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    static group(data, state, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    static page(data, state, dataLength) {
        if (!state) {
            return data;
        }
        const len = dataLength !== undefined ? dataLength : data.length;
        const index = state.index;
        const res = [];
        const recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: len,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    static filter(data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    }
    static correctPagingState(state, length) {
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    static isHierarchyMatch(h1, h2) {
        return isHierarchyMatch(h1, h2);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            const rowId = primaryKey ? item[primaryKey] : item;
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    static parseValue(dataType, value) {
        if (dataType === DataType.Number) {
            value = parseFloat(value);
        }
        return value;
    }
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        let collection = data;
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxVQUFVLEVBQUUsb0JBQW9CLEVBQXdCLE1BQU0sb0JBQW9CLENBQUM7QUFDNUYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBR2xELE9BQU8sRUFBZ0IsV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFNckUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFekQsT0FBTyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekQsT0FBTyxFQUFlLGVBQWUsRUFBMkIsTUFBTSxxQ0FBcUMsQ0FBQztBQUM1RyxPQUFPLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRTlEOztHQUVHO0FBQ0gsTUFBTSxDQUFOLElBQVksUUFLWDtBQUxELFdBQVksUUFBUTtJQUNoQiw2QkFBaUIsQ0FBQTtJQUNqQiw2QkFBaUIsQ0FBQTtJQUNqQiwrQkFBbUIsQ0FBQTtJQUNuQix5QkFBYSxDQUFBO0FBQ2pCLENBQUMsRUFMVyxRQUFRLEtBQVIsUUFBUSxRQUtuQjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFFBQVE7SUFDVixNQUFNLENBQUMsSUFBSSxDQUFJLElBQVMsRUFBRSxXQUFpQyxFQUFFLFVBQWdDLElBQUksVUFBVSxFQUFFO1FBQ2hILE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVNLE1BQU0sQ0FBQyxZQUFZLENBQUMsZ0JBQW1DLEVBQzFELFdBQWlDLEVBQ2pDLFVBQWdDLElBQUksb0JBQW9CLEVBQUUsRUFDMUQsTUFBd0I7UUFDeEIsSUFBSSxH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LFFBQWtCLEVBQUUsS0FBVTtRQUNuRCxJQUFJLFFBQVEsS0FBSyxRQUFRLENBQUMsTUFBTSxFQUFFO1lBQzlCLEtBQUssR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDN0I7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLElBQVcsRUFBRSxVQUFlLEVBQUUsWUFBaUIsRUFBRSxJQUFXO1FBQzFGLElBQUksVUFBVSxHQUFVLElBQUksQ0FBQztRQUM3QixJQUFJLE1BQVcsQ0FBQztRQUVoQixLQUFLLE1BQU0sRUFBRSxJQUFJLElBQUksRUFBRTtZQUNuQixNQUFNLEdBQUcsVUFBVSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDbEUsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDVCxNQUFNO2FBQ1Q7WUFFRCxVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUZpbHRlcmluZ1N0YXRlIH0gZnJvbSAnLi9maWx0ZXJpbmctc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSWd4U29ydGluZywgSWd4RGF0YVJlY29yZFNvcnRpbmcsIElHcmlkU29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElneEdyb3VwaW5nIH0gZnJvbSAnLi9ncm91cGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlc3VsdCB9IGZyb20gJy4vZ3JvdXBpbmctcmVzdWx0LmludGVyZmFjZSc7XG5cbmltcG9ydCB7IElQYWdpbmdTdGF0ZSwgUGFnaW5nRXJyb3IgfSBmcm9tICcuL3BhZ2luZy1zdGF0ZS5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJR3JvdXBCeUtleSB9IGZyb20gJy4vZ3JvdXBieS1leHBhbmQtc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cEJ5UmVjb3JkIH0gZnJvbSAnLi9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwaW5nU3RhdGUgfSBmcm9tICcuL2dyb3VwYnktc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4vc29ydGluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4vZmlsdGVyaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElUcmVlR3JpZFJlY29yZCB9IGZyb20gJy4uL2dyaWRzL3RyZWUtZ3JpZC9wdWJsaWNfYXBpJztcbmltcG9ydCB7IGNsb25lVmFsdWUsIG1lcmdlT2JqZWN0cyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSwgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBnZXRIaWVyYXJjaHksIGlzSGllcmFyY2h5TWF0Y2ggfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGVudW0gRGF0YVR5cGUge1xuICAgIFN0cmluZyA9ICdzdHJpbmcnLFxuICAgIE51bWJlciA9ICdudW1iZXInLFxuICAgIEJvb2xlYW4gPSAnYm9vbGVhbicsXG4gICAgRGF0ZSA9ICdkYXRlJ1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFVdGlsIHtcbiAgICBwdWJsaWMgc3RhdGljIHNvcnQ8VD4oZGF0YTogVFtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneFNvcnRpbmcoKSk6IFRbXSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nLnNvcnQoZGF0YSwgZXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgdHJlZUdyaWRTb3J0KGhpZXJhcmNoaWNhbERhdGE6IElUcmVlR3JpZFJlY29yZFtdLFxuICAgICAgICBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sXG4gICAgICAgIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneERhdGFSZWNvcmRTb3J0aW5nKCksXG4gICAgICAgIHBhcmVudD86IElUcmVlR3JpZFJlY29yZCk6IElUcmVlR3JpZFJlY29yZFtdIHtcbiAgICAgICAgbGV0IHJlczogSVRyZWVHcmlkUmVjb3JkW10gPSBbXTtcbiAgICAgICAgaGllcmFyY2hpY2FsRGF0YS5mb3JFYWNoKChocjogSVRyZWVHcmlkUmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWM6IElUcmVlR3JpZFJlY29yZCA9IERhdGFVdGlsLmNsb25lVHJlZUdyaWRSZWNvcmQoaHIpO1xuICAgICAgICAgICAgcmVjLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChyZWMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZWMuY2hpbGRyZW4gPSBEYXRhVXRpbC50cmVlR3JpZFNvcnQocmVjLmNoaWxkcmVuLCBleHByZXNzaW9ucywgc29ydGluZywgcmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKHJlYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcyA9IERhdGFVdGlsLnNvcnQocmVzLCBleHByZXNzaW9ucywgc29ydGluZyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNsb25lVHJlZUdyaWRSZWNvcmQoaGllcmFyY2hpY2FsUmVjb3JkOiBJVHJlZUdyaWRSZWNvcmQpIHtcbiAgICAgICAgY29uc3QgcmVjOiBJVHJlZUdyaWRSZWNvcmQgPSB7XG4gICAgICAgICAgICByb3dJRDogaGllcmFyY2hpY2FsUmVjb3JkLnJvd0lELFxuICAgICAgICAgICAgZGF0YTogaGllcmFyY2hpY2FsUmVjb3JkLmRhdGEsXG4gICAgICAgICAgICBjaGlsZHJlbjogaGllcmFyY2hpY2FsUmVjb3JkLmNoaWxkcmVuLFxuICAgICAgICAgICAgaXNGaWx0ZXJlZE91dFBhcmVudDogaGllcmFyY2hpY2FsUmVjb3JkLmlzRmlsdGVyZWRPdXRQYXJlbnQsXG4gICAgICAgICAgICBsZXZlbDogaGllcmFyY2hpY2FsUmVjb3JkLmxldmVsLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGhpZXJhcmNoaWNhbFJlY29yZC5leHBhbmRlZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVjO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXA8VD4oZGF0YTogVFtdLCBzdGF0ZTogSUdyb3VwaW5nU3RhdGUsIGdyaWQ6IGFueSA9IG51bGwsXG4gICAgICAgIGdyb3Vwc1JlY29yZHM6IGFueVtdID0gW10sIGZ1bGxSZXN1bHQ6IElHcm91cEJ5UmVzdWx0ID0geyBkYXRhOiBbXSwgbWV0YWRhdGE6IFtdIH0pOiBJR3JvdXBCeVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nID0gbmV3IElneEdyb3VwaW5nKCk7XG4gICAgICAgIGdyb3Vwc1JlY29yZHMuc3BsaWNlKDAsIGdyb3Vwc1JlY29yZHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwaW5nLmdyb3VwQnkoZGF0YSwgc3RhdGUsIGdyaWQsIGdyb3Vwc1JlY29yZHMsIGZ1bGxSZXN1bHQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgcGFnZTxUPihkYXRhOiBUW10sIHN0YXRlOiBJUGFnaW5nU3RhdGUsIGRhdGFMZW5ndGg/OiBudW1iZXIpOiBUW10ge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBkYXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBkYXRhTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBjb25zdCByZWNvcmRzUGVyUGFnZSA9IGRhdGFMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5yZWNvcmRzUGVyUGFnZSA+IGRhdGFMZW5ndGggPyBkYXRhTGVuZ3RoIDogc3RhdGUucmVjb3Jkc1BlclBhZ2U7XG4gICAgICAgIHN0YXRlLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgY291bnRQYWdlczogMCxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkczogbGVuLFxuICAgICAgICAgICAgZXJyb3I6IFBhZ2luZ0Vycm9yLk5vbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpc05hTihpbmRleCkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1ldGFkYXRhLmVycm9yID0gUGFnaW5nRXJyb3IuSW5jb3JyZWN0UGFnZUluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjb3Jkc1BlclBhZ2UgPD0gMCB8fCBpc05hTihyZWNvcmRzUGVyUGFnZSkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1ldGFkYXRhLmVycm9yID0gUGFnaW5nRXJyb3IuSW5jb3JyZWN0UmVjb3Jkc1BlclBhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1ldGFkYXRhLmNvdW50UGFnZXMgPSBNYXRoLmNlaWwobGVuIC8gcmVjb3Jkc1BlclBhZ2UpO1xuICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID49IHN0YXRlLm1ldGFkYXRhLmNvdW50UGFnZXMpIHtcbiAgICAgICAgICAgIHN0YXRlLm1ldGFkYXRhLmVycm9yID0gUGFnaW5nRXJyb3IuSW5jb3JyZWN0UGFnZUluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5zbGljZShpbmRleCAqIHJlY29yZHNQZXJQYWdlLCAoaW5kZXggKyAxKSAqIHJlY29yZHNQZXJQYWdlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZpbHRlcjxUPihkYXRhOiBUW10sIHN0YXRlOiBJRmlsdGVyaW5nU3RhdGUpOiBUW10ge1xuICAgICAgICBpZiAoIXN0YXRlLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBzdGF0ZS5zdHJhdGVneSA9IG5ldyBGaWx0ZXJpbmdTdHJhdGVneSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5zdHJhdGVneS5maWx0ZXIoZGF0YSwgc3RhdGUuZXhwcmVzc2lvbnNUcmVlLCBzdGF0ZS5hZHZhbmNlZEV4cHJlc3Npb25zVHJlZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjb3JyZWN0UGFnaW5nU3RhdGUoc3RhdGU6IElQYWdpbmdTdGF0ZSwgbGVuZ3RoOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWF4UGFnZSA9IE1hdGguY2VpbChsZW5ndGggLyBzdGF0ZS5yZWNvcmRzUGVyUGFnZSkgLSAxO1xuICAgICAgICBpZiAoIWlzTmFOKG1heFBhZ2UpICYmIHN0YXRlLmluZGV4ID4gbWF4UGFnZSkge1xuICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBtYXhQYWdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRIaWVyYXJjaHkoZ1JvdzogSUdyb3VwQnlSZWNvcmQpOiBBcnJheTxJR3JvdXBCeUtleT4ge1xuICAgICAgICByZXR1cm4gZ2V0SGllcmFyY2h5KGdSb3cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNIaWVyYXJjaHlNYXRjaChoMTogQXJyYXk8SUdyb3VwQnlLZXk+LCBoMjogQXJyYXk8SUdyb3VwQnlLZXk+KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc0hpZXJhcmNoeU1hdGNoKGgxLCBoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBjaGFuZ2VzIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb25zIGludG8gcHJvdmlkZWQgZGF0YSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGRhdGEgQ29sbGVjdGlvbiB0byBtZXJnZVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIHRvIG1lcmdlIGludG8gZGF0YVxuICAgICAqIEBwYXJhbSBwcmltYXJ5S2V5IFByaW1hcnkga2V5IG9mIHRoZSBjb2xsZWN0aW9uLCBpZiBhbnlcbiAgICAgKiBAcGFyYW0gZGVsZXRlUm93cyBTaG91bGQgZGVsZXRlIHJvd3Mgd2l0aCBERUxFVEUgdHJhbnNhY3Rpb24gdHlwZSBmcm9tIGRhdGFcbiAgICAgKiBAcmV0dXJucyBQcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25zIHVwZGF0ZWQgd2l0aCBhbGwgcHJvdmlkZWQgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZVRyYW5zYWN0aW9uczxUPihkYXRhOiBUW10sIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSwgcHJpbWFyeUtleT86IGFueSwgZGVsZXRlUm93czogYm9vbGVhbiA9IGZhbHNlKTogVFtdIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKChpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0lkID0gcHJpbWFyeUtleSA/IGl0ZW1bcHJpbWFyeUtleV0gOiBpdGVtO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnMuZmluZCh0ID0+IHQuaWQgPT09IHJvd0lkKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSB0cmFuc2FjdGlvbi5uZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRlbGV0ZVJvd3MpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJpbWFyeUtleSA/IGRhdGEuZmluZEluZGV4KGQgPT4gZFtwcmltYXJ5S2V5XSA9PT0gdC5pZCkgOiBkYXRhLmZpbmRJbmRleChkID0+IGQgPT09IHQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA8PSBpbmRleCAmJiBpbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucHVzaCguLi50cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BREQpXG4gICAgICAgICAgICAubWFwKHQgPT4gdC5uZXdWYWx1ZSkpO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwgY2hhbmdlcyBmcm9tIHByb3ZpZGVkIHRyYW5zYWN0aW9ucyBpbnRvIHByb3ZpZGVkIGhpZXJhcmNoaWNhbCBkYXRhIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZGF0YSBDb2xsZWN0aW9uIHRvIG1lcmdlXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgdG8gbWVyZ2UgaW50byBkYXRhXG4gICAgICogQHBhcmFtIGNoaWxkRGF0YUtleSBEYXRhIGtleSBvZiBjaGlsZCBjb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSBwcmltYXJ5S2V5IFByaW1hcnkga2V5IG9mIHRoZSBjb2xsZWN0aW9uLCBpZiBhbnlcbiAgICAgKiBAcGFyYW0gZGVsZXRlUm93cyBTaG91bGQgZGVsZXRlIHJvd3Mgd2l0aCBERUxFVEUgdHJhbnNhY3Rpb24gdHlwZSBmcm9tIGRhdGFcbiAgICAgKiBAcmV0dXJucyBQcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25zIHVwZGF0ZWQgd2l0aCBhbGwgcHJvdmlkZWQgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZUhpZXJhcmNoaWNhbFRyYW5zYWN0aW9ucyhcbiAgICAgICAgZGF0YTogYW55W10sXG4gICAgICAgIHRyYW5zYWN0aW9uczogSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25bXSxcbiAgICAgICAgY2hpbGREYXRhS2V5OiBhbnksXG4gICAgICAgIHByaW1hcnlLZXk/OiBhbnksXG4gICAgICAgIGRlbGV0ZVJvd3M6IGJvb2xlYW4gPSBmYWxzZSk6IGFueVtdIHtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5wYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5maW5kUGFyZW50RnJvbVBhdGgoZGF0YSwgcHJpbWFyeUtleSwgY2hpbGREYXRhS2V5LCB0cmFuc2FjdGlvbi5wYXRoKTtcbiAgICAgICAgICAgICAgICBsZXQgY29sbGVjdGlvbjogYW55W10gPSBwYXJlbnQgPyBwYXJlbnRbY2hpbGREYXRhS2V5XSA6IGRhdGE7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cmFuc2FjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFERDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBwYXJlbnQgdGhpcyBpcyBBREQgcm93IGF0IHJvb3QgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudFtjaGlsZERhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50W2NoaWxkRGF0YUtleV0gPSBjb2xsZWN0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2godHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlVQREFURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gY29sbGVjdGlvbi5maW5kSW5kZXgoeCA9PiB4W3ByaW1hcnlLZXldID09PSB0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblt1cGRhdGVJbmRleF0gPSBtZXJnZU9iamVjdHMoY2xvbmVWYWx1ZShjb2xsZWN0aW9uW3VwZGF0ZUluZGV4XSksIHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlUm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUluZGV4ID0gY29sbGVjdGlvbi5maW5kSW5kZXgociA9PiByW3ByaW1hcnlLZXldID09PSB0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShkZWxldGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgaWYgdGhlcmUgaXMgbm8gcGF0aCB0aGlzIGlzIEFERCByb3cgaW4gcm9vdC4gUHVzaCB0aGUgbmV3VmFsdWUgdG8gZGF0YVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZVZhbHVlKGRhdGFUeXBlOiBEYXRhVHlwZSwgdmFsdWU6IGFueSk6IGFueSB7XG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gRGF0YVR5cGUuTnVtYmVyKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGZpbmRQYXJlbnRGcm9tUGF0aChkYXRhOiBhbnlbXSwgcHJpbWFyeUtleTogYW55LCBjaGlsZERhdGFLZXk6IGFueSwgcGF0aDogYW55W10pOiBhbnkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbjogYW55W10gPSBkYXRhO1xuICAgICAgICBsZXQgcmVzdWx0OiBhbnk7XG5cbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uZmluZCh4ID0+IHhbcHJpbWFyeUtleV0gPT09IGlkKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSByZXN1bHRbY2hpbGREYXRhS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIl19