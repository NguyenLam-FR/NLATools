import { ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, Renderer2, ChangeDetectorRef, ViewContainerRef, AfterContentInit, TemplateRef, QueryList } from '@angular/core';
import { Subject } from 'rxjs';
import { IBaseEventArgs } from '../../core/utils';
import { IDropStrategy } from './drag-drop.strategy';
import * as ɵngcc0 from '@angular/core';
export declare enum DragDirection {
    VERTICAL = 0,
    HORIZONTAL = 1,
    BOTH = 2
}
export interface IgxDragCustomEventDetails {
    startX: number;
    startY: number;
    pageX: number;
    pageY: number;
    owner: IgxDragDirective;
    originalEvent: any;
}
export interface IDropBaseEventArgs extends IBaseEventArgs {
    /**
     * Reference to the original event that caused the draggable element to enter the igxDrop element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     */
    originalEvent: any;
    /** The owner igxDrop directive that triggered this event. */
    owner: IgxDropDirective;
    /** The igxDrag directive instanced on an element that entered the area of the igxDrop element */
    drag: IgxDragDirective;
    /** The data contained for the draggable element in igxDrag directive. */
    dragData: any;
    /** The initial position of the pointer on X axis when the dragged element began moving */
    startX: number;
    /** The initial position of the pointer on Y axis when the dragged element began moving */
    startY: number;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageX: number;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageY: number;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    offsetX: number;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    offsetY: number;
}
export interface IDropDroppedEventArgs extends IDropBaseEventArgs {
    /** Specifies if the default drop logic related to the event should be canceled. */
    cancel: boolean;
}
export interface IDragBaseEventArgs extends IBaseEventArgs {
    /**
     * Reference to the original event that caused the interaction with the element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     */
    originalEvent: PointerEvent | MouseEvent | TouchEvent;
    /** The owner igxDrag directive that triggered this event. */
    owner: IgxDragDirective;
    /** The initial position of the pointer on X axis when the dragged element began moving */
    startX: number;
    /** The initial position of the pointer on Y axis when the dragged element began moving */
    startY: number;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageX: number;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageY: number;
}
export interface IDragStartEventArgs extends IDragBaseEventArgs {
    /** Set if the the dragging should be canceled. */
    cancel: boolean;
}
export interface IDragMoveEventArgs extends IDragStartEventArgs {
    /** The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element X movement. */
    nextPageX: number;
    /** The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element Y movement. */
    nextPageY: number;
}
export interface IDragGhostBaseEventArgs extends IBaseEventArgs {
    /** The owner igxDrag directive that triggered this event. */
    owner: IgxDragDirective;
    /** Instance to the ghost element that is created when dragging starts. */
    ghostElement: any;
    /** Set if the ghost creation/destruction should be canceled. */
    cancel: boolean;
}
export interface IDragCustomTransitionArgs {
    duration?: number;
    timingFunction?: string;
    delay?: number;
}
export declare class IgxDragLocation {
    private _pageX;
    private _pageY;
    pageX: number;
    pageY: number;
    constructor(_pageX: any, _pageY: any);
}
export declare class IgxDragHandleDirective {
    element: ElementRef<any>;
    baseClass: boolean;
    constructor(element: ElementRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragHandleDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragHandleDirective, "[igxDragHandle]", never, {}, {}, never>;
}
export declare class IgxDragIgnoreDirective {
    element: ElementRef<any>;
    baseClass: boolean;
    constructor(element: ElementRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragIgnoreDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragIgnoreDirective, "[igxDragIgnore]", never, {}, {}, never>;
}
export declare class IgxDragDirective implements AfterContentInit, OnDestroy {
    cdr: ChangeDetectorRef;
    element: ElementRef;
    viewContainer: ViewContainerRef;
    zone: NgZone;
    renderer: Renderer2;
    protected ghostContext: any;
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * @memberof IgxDragDirective
     */
    data: any;
    /**
     * An @Input property that indicates when the drag should start.
     * By default the drag starts after the draggable element is moved by 5px.
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    dragTolerance: number;
    /**
     * An @Input property that indicates the directions that the element can be dragged.
     * By default it is set to both horizontal and vertical directions.
     * ```html
     * <div igxDrag [dragDirection]="dragDir">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public dragDir = DragDirection.HORIZONTAL;
     * ```
     * @memberof IgxDragDirective
     */
    dragDirection: DragDirection;
    /**
     * An @Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    dragChannel: number | string | number[] | string[];
    /**
     * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
     * By default it is set to `true`.
     * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
     * ```html
     * <div igxDrag [ghost]="false">
     *      <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghost: boolean;
    /**
     * Sets a custom class that will be added to the `ghostElement` element.
     * ```html
     * <div igxDrag [ghostClass]="'ghostElement'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghostClass: string;
    /**
     * An @Input property that specifies a template for the ghost element created when dragging starts and `ghost` is true.
     * By default a clone of the base element the igxDrag is instanced is created.
     * ```html
     * <div igxDrag [ghostTemplate]="customGhost">
     *         <span>Drag Me!</span>
     * </div>
     * <ng-template #customGhost>
     *      <div class="customGhostStyle">
     *          <span>I am being dragged!</span>
     *      </div>
     * </ng-template>
     * ```
     * @memberof IgxDragDirective
     */
    ghostTemplate: TemplateRef<any>;
    /**
     * An @Input property that sets the element to which the dragged element will be appended.
     * By default it's set to null and the dragged element is appended to the body.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostHost]="hostDiv">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghostHost: any;
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value: any);
    get ghostOffsetX(): any;
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value: any);
    get ghostOffsetY(): any;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragStart: EventEmitter<IDragStartEventArgs>;
    /**
     * Event triggered when the draggable element has been moved.
     * ```html
     * <div igxDrag  (dragMove)="onDragMove()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragMove(){
     *      alert("The element has moved!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragMove: EventEmitter<IDragMoveEventArgs>;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragEnd: EventEmitter<IDragBaseEventArgs>;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag (dragClick)="onDragClick()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragClick(){
     *      alert("The element has been clicked!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragClick: EventEmitter<IDragBaseEventArgs>;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostCreate)="ghostCreated()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostCreated(){
     *      alert("The ghost has been created!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    ghostCreate: EventEmitter<IDragGhostBaseEventArgs>;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostDestroy)="ghostDestroyed()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostDestroyed(){
     *      alert("The ghost has been destroyed!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    ghostDestroy: EventEmitter<IDragGhostBaseEventArgs>;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag (transitioned)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    transitioned: EventEmitter<IDragBaseEventArgs>;
    /**
     * @hidden
     */
    dragHandles: QueryList<IgxDragHandleDirective>;
    /**
     * @hidden
     */
    dragIgnoredElems: QueryList<IgxDragIgnoreDirective>;
    /**
     * @hidden
     */
    baseClass: boolean;
    /**
     * @hidden
     */
    selectDisabled: boolean;
    /**
     * Gets the current location of the element relative to the page.
     */
    get location(): IgxDragLocation;
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation(): IgxDragLocation;
    /**
     * @hidden
     */
    get pointerEventsEnabled(): boolean;
    /**
     * @hidden
     */
    get touchEventsEnabled(): boolean;
    /**
     * @hidden
     */
    get pageX(): number;
    /**
     * @hidden
     */
    get pageY(): number;
    protected get baseLeft(): number;
    protected get baseTop(): number;
    protected get baseOriginLeft(): number;
    protected get baseOriginTop(): number;
    protected set ghostLeft(pageX: number);
    protected get ghostLeft(): number;
    protected set ghostTop(pageY: number);
    protected get ghostTop(): number;
    /**
     * @hidden
     */
    defaultReturnDuration: string;
    /**
     * @hidden
     */
    ghostElement: any;
    /**
     * @hidden
     */
    animInProgress: boolean;
    protected _startX: number;
    protected _startY: number;
    protected _lastX: number;
    protected _lastY: number;
    protected _dragStarted: boolean;
    /** Drag ghost related properties */
    protected _defaultOffsetX: any;
    protected _defaultOffsetY: any;
    protected _offsetX: any;
    protected _offsetY: any;
    protected _ghostStartX: any;
    protected _ghostStartY: any;
    protected _ghostHostX: number;
    protected _ghostHostY: number;
    protected _pointerDownId: any;
    protected _clicked: boolean;
    protected _lastDropArea: any;
    protected _destroy: Subject<boolean>;
    protected _removeOnDestroy: boolean;
    constructor(cdr: ChangeDetectorRef, element: ElementRef, viewContainer: ViewContainerRef, zone: NgZone, renderer: Renderer2);
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation: IgxDragLocation): void;
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs?: IDragCustomTransitionArgs, startLocation?: IgxDragLocation): void;
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target: IgxDragLocation | ElementRef, customAnimArgs?: IDragCustomTransitionArgs, startLocation?: IgxDragLocation): void;
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event: any): void;
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event: any): void;
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event: any): void;
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event: any): void;
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    protected createGhost(pageX: any, pageY: any, node?: any): void;
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    protected dispatchDragEvents(pageX: number, pageY: number, originalEvent: any): void;
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    protected dispatchDropEvent(pageX: number, pageY: number, originalEvent: any): void;
    /**
     * @hidden
     */
    onTransitionEnd(event: any): void;
    /**
     * @hidden
     */
    protected getElementsAtPoint(pageX: number, pageY: number): any;
    /**
     * @hidden
     */
    protected dispatchEvent(target: any, eventName: string, eventArgs: IgxDragCustomEventDetails): void;
    protected getTransformX(elem: any): number;
    protected getTransformY(elem: any): number;
    /** Method setting transformation to the base draggable element. */
    protected setTransformXY(x: number, y: number): void;
    protected getWindowScrollTop(): number;
    protected getWindowScrollLeft(): number;
    protected ghostHostOffsetLeft(ghostHost: any): number;
    protected ghostHostOffsetTop(ghostHost: any): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragDirective, "[igxDrag]", ["drag"], { "dragTolerance": "dragTolerance"; "dragDirection": "dragDirection"; "ghost": "ghost"; "ghostClass": "ghostClass"; "ghostOffsetX": "ghostOffsetX"; "ghostOffsetY": "ghostOffsetY"; "data": "igxDrag"; "dragChannel": "dragChannel"; "ghostTemplate": "ghostTemplate"; "ghostHost": "ghostHost"; }, { "dragStart": "dragStart"; "dragMove": "dragMove"; "dragEnd": "dragEnd"; "dragClick": "dragClick"; "ghostCreate": "ghostCreate"; "ghostDestroy": "ghostDestroy"; "transitioned": "transitioned"; }, ["dragHandles", "dragIgnoredElems"]>;
}
export declare class IgxDropDirective implements OnInit, OnDestroy {
    element: ElementRef;
    private _renderer;
    private _zone;
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * @memberof IgxDropDirective
     */
    data: any;
    /**
     * An @Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * @memberof IgxDropDirective
     */
    dropChannel: number | string | number[] | string[];
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef: any);
    get dropStrategy(): any;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    enter: EventEmitter<IDropBaseEventArgs>;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    over: EventEmitter<IDropBaseEventArgs>;
    /**
     * Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable element has left the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    leave: EventEmitter<IDropBaseEventArgs>;
    /**
     * Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable element has been dropped in the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    dropped: EventEmitter<IDropDroppedEventArgs>;
    /**
     * @hidden
     */
    droppable: boolean;
    /**
     * @hidden
     */
    dragover: boolean;
    /**
     * @hidden
     */
    protected _destroy: Subject<boolean>;
    protected _dropStrategy: IDropStrategy;
    constructor(element: ElementRef, _renderer: Renderer2, _zone: NgZone);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    onDragOver(event: any): void;
    /**
     * @hidden
     */
    onDragEnter(event: CustomEvent<IgxDragCustomEventDetails>): void;
    /**
     * @hidden
     */
    onDragLeave(event: any): void;
    /**
     * @hidden
     */
    onDragDrop(event: any): void;
    protected getWindowScrollTop(): number;
    protected getWindowScrollLeft(): number;
    protected isDragLinked(drag: IgxDragDirective): boolean;
    protected getInsertIndexAt(draggedDir: IgxDragDirective, elementsAtPoint: any[]): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDropDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDropDirective, "[igxDrop]", ["drop"], { "dropStrategy": "dropStrategy"; "data": "igxDrop"; "dropChannel": "dropChannel"; }, { "enter": "enter"; "over": "over"; "leave": "leave"; "dropped": "dropped"; }, never>;
}
/**
 * @hidden
 */
export declare class IgxDragDropModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxDragDropModule, [typeof IgxDragDirective, typeof IgxDropDirective, typeof IgxDragHandleDirective, typeof IgxDragIgnoreDirective], never, [typeof IgxDragDirective, typeof IgxDropDirective, typeof IgxDragHandleDirective, typeof IgxDragIgnoreDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxDragDropModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkcmFnLWRyb3AuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBDaGFuZ2VEZXRlY3RvclJlZiwgVmlld0NvbnRhaW5lclJlZiwgQWZ0ZXJDb250ZW50SW5pdCwgVGVtcGxhdGVSZWYsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElEcm9wU3RyYXRlZ3kgfSBmcm9tICcuL2RyYWctZHJvcC5zdHJhdGVneSc7XG5leHBvcnQgZGVjbGFyZSBlbnVtIERyYWdEaXJlY3Rpb24ge1xuICAgIFZFUlRJQ0FMID0gMCxcbiAgICBIT1JJWk9OVEFMID0gMSxcbiAgICBCT1RIID0gMlxufVxuZXhwb3J0IGludGVyZmFjZSBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzIHtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgb3JpZ2luYWxFdmVudDogYW55O1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJvcEJhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgdG8gZW50ZXIgdGhlIGlneERyb3AgZWxlbWVudC5cbiAgICAgKiBDYW4gYmUgUG9pbnRlckV2ZW50LCBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQuXG4gICAgICovXG4gICAgb3JpZ2luYWxFdmVudDogYW55O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJvcCBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJvcERpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGlneERyYWcgZGlyZWN0aXZlIGluc3RhbmNlZCBvbiBhbiBlbGVtZW50IHRoYXQgZW50ZXJlZCB0aGUgYXJlYSBvZiB0aGUgaWd4RHJvcCBlbGVtZW50ICovXG4gICAgZHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGZvciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaW4gaWd4RHJhZyBkaXJlY3RpdmUuICovXG4gICAgZHJhZ0RhdGE6IGFueTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRYOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgdGhhdCBpbml0aWFsaXplcyB0aGUgaWd4RHJvcC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgb2Zmc2V0WTogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJvcERyb3BwZWRFdmVudEFyZ3MgZXh0ZW5kcyBJRHJvcEJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBTcGVjaWZpZXMgaWYgdGhlIGRlZmF1bHQgZHJvcCBsb2dpYyByZWxhdGVkIHRvIHRoZSBldmVudCBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0Jhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWxlbWVudC5cbiAgICAgKiBDYW4gYmUgUG9pbnRlckV2ZW50LCBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQuXG4gICAgICovXG4gICAgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IHwgTW91c2VFdmVudCB8IFRvdWNoRXZlbnQ7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcmFnIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWTogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ1N0YXJ0RXZlbnRBcmdzIGV4dGVuZHMgSURyYWdCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogU2V0IGlmIHRoZSB0aGUgZHJhZ2dpbmcgc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdNb3ZlRXZlbnRBcmdzIGV4dGVuZHMgSURyYWdTdGFydEV2ZW50QXJncyB7XG4gICAgLyoqIFRoZSBuZXcgcGFnZVggcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgdGhhdCB0aGUgaWd4RHJhZyB3aWxsIHVzZS4gSXQgY2FuIGJlIG92ZXJyaWRkZW4gdG8gbGltaXQgZHJhZ2dlZCBlbGVtZW50IFggbW92ZW1lbnQuICovXG4gICAgbmV4dFBhZ2VYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBuZXcgcGFnZVggcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgdGhhdCB0aGUgaWd4RHJhZyB3aWxsIHVzZS4gSXQgY2FuIGJlIG92ZXJyaWRkZW4gdG8gbGltaXQgZHJhZ2dlZCBlbGVtZW50IFkgbW92ZW1lbnQuICovXG4gICAgbmV4dFBhZ2VZOiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJhZyBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogSW5zdGFuY2UgdG8gdGhlIGdob3N0IGVsZW1lbnQgdGhhdCBpcyBjcmVhdGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLiAqL1xuICAgIGdob3N0RWxlbWVudDogYW55O1xuICAgIC8qKiBTZXQgaWYgdGhlIGdob3N0IGNyZWF0aW9uL2Rlc3RydWN0aW9uIHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3Mge1xuICAgIGR1cmF0aW9uPzogbnVtYmVyO1xuICAgIHRpbWluZ0Z1bmN0aW9uPzogc3RyaW5nO1xuICAgIGRlbGF5PzogbnVtYmVyO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4RHJhZ0xvY2F0aW9uIHtcbiAgICBwcml2YXRlIF9wYWdlWDtcbiAgICBwcml2YXRlIF9wYWdlWTtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgY29uc3RydWN0b3IoX3BhZ2VYOiBhbnksIF9wYWdlWTogYW55KTtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdIYW5kbGVEaXJlY3RpdmUge1xuICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY8YW55PjtcbiAgICBiYXNlQ2xhc3M6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZjxhbnk+KTtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdJZ25vcmVEaXJlY3RpdmUge1xuICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY8YW55PjtcbiAgICBiYXNlQ2xhc3M6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZjxhbnk+KTtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgZWxlbWVudDogRWxlbWVudFJlZjtcbiAgICB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xuICAgIHpvbmU6IE5nWm9uZTtcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyO1xuICAgIHByb3RlY3RlZCBnaG9zdENvbnRleHQ6IGFueTtcbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcmFnYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyYWdgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyYWddPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkYXRhOiBhbnk7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIHdoZW4gdGhlIGRyYWcgc2hvdWxkIHN0YXJ0LlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGRyYWcgc3RhcnRzIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBtb3ZlZCBieSA1cHguXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ1RvbGVyYW5jZV09XCIxMDBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJhZ1RvbGVyYW5jZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB0aGUgZGlyZWN0aW9ucyB0aGF0IHRoZSBlbGVtZW50IGNhbiBiZSBkcmFnZ2VkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGJvdGggaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGlyZWN0aW9ucy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnRGlyZWN0aW9uXT1cImRyYWdEaXJcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uSE9SSVpPTlRBTDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdEaXJlY3Rpb246IERyYWdEaXJlY3Rpb247XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgcHJvdmlkZSBhIHdheSBmb3IgaWd4RHJhZyBhbmQgaWd4RHJvcCB0byBiZSBsaW5rZWQgdGhyb3VnaCBjaGFubmVscy5cbiAgICAgKiBJdCBhY2NlcHRzIHNpbmdsZSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMgYW5kIGV2YWx1YXRlcyB0aGVuIHVzaW5nIHN0cmljdCBlcXVhbGl0eS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnQ2hhbm5lbF09XCInb2RkJ1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+OTU8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcm9wIFtkcm9wQ2hhbm5lbF09XCJbJ29kZCcsICdpcnJhdGlvbmFsJ11cIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPk51bWJlcnMgZHJvcCBhcmVhITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdDaGFubmVsOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSB8IHN0cmluZ1tdO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBpZiB0aGUgYmFzZSBlbGVtZW50IHNob3VsZCBub3QgYmUgbW92ZWQgYW5kIGEgZ2hvc3QgZWxlbWVudCBzaG91bGQgYmUgcmVuZGVyZWQgdGhhdCByZXByZXNlbnRzIGl0LlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKiBJZiBpdCBpcyBzZXQgdG8gYGZhbHNlYCB3aGVuIGRyYWdnaW5nIHRoZSBiYXNlIGVsZW1lbnQgaXMgbW92ZWQgaW5zdGVhZCBhbmQgbm8gZ2hvc3QgZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0XT1cImZhbHNlXCI+XG4gICAgICogICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGdob3N0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjdXN0b20gY2xhc3MgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBgZ2hvc3RFbGVtZW50YCBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0Q2xhc3NdPVwiJ2dob3N0RWxlbWVudCdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZ2hvc3RDbGFzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBhIHRlbXBsYXRlIGZvciB0aGUgZ2hvc3QgZWxlbWVudCBjcmVhdGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzIGFuZCBgZ2hvc3RgIGlzIHRydWUuXG4gICAgICogQnkgZGVmYXVsdCBhIGNsb25lIG9mIHRoZSBiYXNlIGVsZW1lbnQgdGhlIGlneERyYWcgaXMgaW5zdGFuY2VkIGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RUZW1wbGF0ZV09XCJjdXN0b21HaG9zdFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPG5nLXRlbXBsYXRlICNjdXN0b21HaG9zdD5cbiAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJjdXN0b21HaG9zdFN0eWxlXCI+XG4gICAgICogICAgICAgICAgPHNwYW4+SSBhbSBiZWluZyBkcmFnZ2VkITwvc3Bhbj5cbiAgICAgKiAgICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGRyYWdnZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gbnVsbCBhbmQgdGhlIGRyYWdnZWQgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0SG9zdF09XCJob3N0RGl2XCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGdob3N0SG9zdDogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIG1vdXNlIGluIHBpeGVscy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3MgdGFraW5nIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgbW91c2Ugd2hlbiB0aGUgZHJhZyBzdGFydGVkIGFuZCBrZWVwcyBpdCB0aGUgc2FtZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0T2Zmc2V0WF09XCIwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIHNldCBnaG9zdE9mZnNldFgodmFsdWU6IGFueSk7XG4gICAgZ2V0IGdob3N0T2Zmc2V0WCgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGRyYWdnZWQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgbW91c2UgaW4gcGl4ZWxzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyB0YWtpbmcgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBtb3VzZSB3aGVuIHRoZSBkcmFnIHN0YXJ0ZWQgYW5kIGtlZXBzIGl0IHRoZSBzYW1lLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RPZmZzZXRZXT1cIjBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgc2V0IGdob3N0T2Zmc2V0WSh2YWx1ZTogYW55KTtcbiAgICBnZXQgZ2hvc3RPZmZzZXRZKCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZHJhZyBzdGFydHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ1N0YXJ0KT1cIm9uRHJhZ1N0YXJ0KClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnU3RhcnQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIHN0YXJlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8SURyYWdTdGFydEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIG1vdmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgIChkcmFnTW92ZSk9XCJvbkRyYWdNb3ZlKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnTW92ZSgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgbW92ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdNb3ZlOiBFdmVudEVtaXR0ZXI8SURyYWdNb3ZlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ0VuZCk9XCJvbkRyYWdFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnRW5kOiBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnQ2xpY2spPVwib25EcmFnQ2xpY2soKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdDbGljaygpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgYmVlbiBjbGlja2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnQ2xpY2s6IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdENyZWF0ZSk9XCJnaG9zdENyZWF0ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdENyZWF0ZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGdob3N0IGhhcyBiZWVuIGNyZWF0ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGdob3N0Q3JlYXRlOiBFdmVudEVtaXR0ZXI8SURyYWdHaG9zdEJhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdERlc3Ryb3kpPVwiZ2hvc3REZXN0cm95ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdERlc3Ryb3llZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZ2hvc3QgaGFzIGJlZW4gZGVzdHJveWVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdERlc3Ryb3k6IEV2ZW50RW1pdHRlcjxJRHJhZ0dob3N0QmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZCBhbmQgYWZ0ZXIgaXRzIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAodHJhbnNpdGlvbmVkKT1cIm9uTW92ZUVuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uTW92ZUVuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgbW92ZSBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25lZDogRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyYWdIYW5kbGVzOiBRdWVyeUxpc3Q8SWd4RHJhZ0hhbmRsZURpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyYWdJZ25vcmVkRWxlbXM6IFF1ZXJ5TGlzdDxJZ3hEcmFnSWdub3JlRGlyZWN0aXZlPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYmFzZUNsYXNzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZWxlY3REaXNhYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZSBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqL1xuICAgIGdldCBsb2NhdGlvbigpOiBJZ3hEcmFnTG9jYXRpb247XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIGVsZW1lbnQgYmVmb3JlIGRyYWdnaW5nIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgZ2V0IG9yaWdpbkxvY2F0aW9uKCk6IElneERyYWdMb2NhdGlvbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBvaW50ZXJFdmVudHNFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0b3VjaEV2ZW50c0VuYWJsZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VYKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VZKCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VMZWZ0KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VUb3AoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXQgYmFzZU9yaWdpbkxlZnQoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXQgYmFzZU9yaWdpblRvcCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIHNldCBnaG9zdExlZnQocGFnZVg6IG51bWJlcik7XG4gICAgcHJvdGVjdGVkIGdldCBnaG9zdExlZnQoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBzZXQgZ2hvc3RUb3AocGFnZVk6IG51bWJlcik7XG4gICAgcHJvdGVjdGVkIGdldCBnaG9zdFRvcCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRlZmF1bHRSZXR1cm5EdXJhdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnaG9zdEVsZW1lbnQ6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYW5pbUluUHJvZ3Jlc3M6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIF9zdGFydFg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfbGFzdFg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2xhc3RZOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9kcmFnU3RhcnRlZDogYm9vbGVhbjtcbiAgICAvKiogRHJhZyBnaG9zdCByZWxhdGVkIHByb3BlcnRpZXMgKi9cbiAgICBwcm90ZWN0ZWQgX2RlZmF1bHRPZmZzZXRYOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9kZWZhdWx0T2Zmc2V0WTogYW55O1xuICAgIHByb3RlY3RlZCBfb2Zmc2V0WDogYW55O1xuICAgIHByb3RlY3RlZCBfb2Zmc2V0WTogYW55O1xuICAgIHByb3RlY3RlZCBfZ2hvc3RTdGFydFg6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0U3RhcnRZOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9naG9zdEhvc3RYOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9naG9zdEhvc3RZOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9wb2ludGVyRG93bklkOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9jbGlja2VkOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBfbGFzdERyb3BBcmVhOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9kZXN0cm95OiBTdWJqZWN0PGJvb2xlYW4+O1xuICAgIHByb3RlY3RlZCBfcmVtb3ZlT25EZXN0cm95OiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsIHpvbmU6IE5nWm9uZSwgcmVuZGVyZXI6IFJlbmRlcmVyMik7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNldHMgZGVzaXJlZCBsb2NhdGlvbiBvZiB0aGUgYmFzZSBlbGVtZW50IG9yIGdob3N0IGVsZW1lbnQgaWYgcmVuZGVkIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gbmV3TG9jYXRpb24gTmV3IGxvY2F0aW9uIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQuIEl0IGlzIGFkdmlzZWQgdG8gZ2V0IG5ldyBsb2NhdGlvbiB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3RzKCkgKyBzY3JvbGwuXG4gICAgICovXG4gICAgc2V0TG9jYXRpb24obmV3TG9jYXRpb246IElneERyYWdMb2NhdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGJhc2Ugb3IgZ2hvc3QgZWxlbWVudCBkZXBlbmRpbmcgb24gdGhlIGBnaG9zdGAgaW5wdXQgdG8gaXRzIGluaXRpYWwgbG9jYXRpb24uXG4gICAgICogSWYgYGdob3N0YCBpcyB0cnVlIGJ1dCB0aGVyZSBpcyBub3QgZ2hvc3QgcmVuZGVyZWQsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgYW5pbWF0ZWQuXG4gICAgICogSWYgdGhlIGJhc2UgZWxlbWVudCBoYXMgY2hhbmdlZCBpdHMgRE9NIHBvc2l0aW9uIGl0cyBpbml0aWFsIGxvY2F0aW9uIHdpbGwgYmUgY2hhbmdlZCBhY2NvcmRpbmdseS5cbiAgICAgKiBAcGFyYW0gY3VzdG9tQW5pbUFyZ3MgQ3VzdG9tIHRyYW5zaXRpb24gcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHN0YXJ0TG9jYXRpb24gU3RhcnQgbG9jYXRpb24gZnJvbSB3aGVyZSB0aGUgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnQuXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRvT3JpZ2luKGN1c3RvbUFuaW1BcmdzPzogSURyYWdDdXN0b21UcmFuc2l0aW9uQXJncywgc3RhcnRMb2NhdGlvbj86IElneERyYWdMb2NhdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGJhc2Ugb3IgZ2hvc3QgZWxlbWVudCB0byBhIHNwZWNpZmljIHRhcmdldCBsb2NhdGlvbiBvciBvdGhlciBlbGVtZW50IHVzaW5nIHRyYW5zaXRpb24uXG4gICAgICogSWYgYGdob3N0YCBpcyB0cnVlIGJ1dCB0aGVyZSBpcyBub3QgZ2hvc3QgcmVuZGVyZWQsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgYW5pbWF0ZWQuXG4gICAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlICdnZXRCb3VuZGluZ0NsaWVudFJlY3RzKCkgKyBwYWdlU2Nyb2xsJyB3aGVuIGRldGVybWluaW5nIGRlc2lyZWQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgdGhhdCB0aGUgYmFzZSBvciBnaG9zdCB3aWxsIHRyYW5zaXRpb24gdG8uIEl0IGNhbiBiZSBlaXRoZXIgbG9jYXRpb24gaW4gdGhlIHBhZ2Ugb3IgYW5vdGhlciBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGN1c3RvbUFuaW1BcmdzIEN1c3RvbSB0cmFuc2l0aW9uIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBzdGFydExvY2F0aW9uIFN0YXJ0IGxvY2F0aW9uIGZyb20gd2hlcmUgdGhlIHRyYW5zaXRpb24gc2hvdWxkIHN0YXJ0LlxuICAgICAqL1xuICAgIHRyYW5zaXRpb25Ubyh0YXJnZXQ6IElneERyYWdMb2NhdGlvbiB8IEVsZW1lbnRSZWYsIGN1c3RvbUFuaW1BcmdzPzogSURyYWdDdXN0b21UcmFuc2l0aW9uQXJncywgc3RhcnRMb2NhdGlvbj86IElneERyYWdMb2NhdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCBib3VuZCB0byB0aGUgUG9pbnRlckRvd24gZXZlbnQgb2YgdGhlIGJhc2UgZWxlbWVudCBpZ3hEcmFnIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyRG93biBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIG9uUG9pbnRlckRvd24oZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZvcm0gZHJhZyBtb3ZlIGxvZ2ljIHdoZW4gZHJhZ2dpbmcgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cyBpZiB0aGVyZSBpcyBpZ3hEcm9wIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJvdW5kIGF0IGZpcnN0IGF0IHRoZSBiYXNlIGVsZW1lbnQuXG4gICAgICogSWYgZHJhZ2dpbmcgc3RhcnRzIGFuZCBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbmRlcmVkIHRoZSBwb2ludGVySWQgaXMgcmVhc3NpZ25lZCBpdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlck1vdmUgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBvblBvaW50ZXJNb3ZlKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBQZXJmb3JtIGRyYWcgZW5kIGxvZ2ljIHdoZW4gcmVsZWFzaW5nIHRoZSBnaG9zdEVsZW1lbnQgYW5kIGRpc3BhdGNoaW5nIGRyb3AgZXZlbnQgaWYgaWd4RHJvcCBpcyB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCBhdCBmaXJzdCBhdCB0aGUgYmFzZSBlbGVtZW50LlxuICAgICAqIElmIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYWZ0ZXIgdGhlIGdob3N0RWxlbWVudCBpcyByZW5kZXJlZCB0aGUgcG9pbnRlcklkIGlzIHJlYXNzaWduZWQgdG8gaXQuIFRoZW4gdGhpcyBtZXRob2QgaXMgYm91bmQgdG8gaXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJVcCBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIG9uUG9pbnRlclVwKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBFeGVjdXRlIHRoaXMgbWV0aG9kIHdoZSB0aGUgcG9pbnRlciBjYXB0dXJlIGhhcyBiZWVuIGxvc3QuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGR1cmluZyBkcmFnZ2luZyB0aGUgdXNlciBoYXMgcGVyZm9ybWVkIG90aGVyIGFjdGlvbiBsaWtlIHJpZ2h0IGNsaWNraW5nIGFuZCB0aGVuIGNsaWNraW5nIHNvbWV3aGVyZSBlbHNlLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGRyYWcgc3RhdGUgaXMgYmVpbmcgcmVzZXQgaW4gdGhpcyBjYXNlIGFzIGlmIHRoZSB1c2VyIHJlbGVhc2VkIHRoZSBkcmFnZ2VkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGV2ZW50IEV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgb25Qb2ludGVyTG9zdChldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ3JlYXRlIGdob3N0IGVsZW1lbnQgLSBpZiBhIE5vZGUgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGNyZWF0ZXMgYSBjbG9uZSBvZiB0aGF0IG5vZGUsXG4gICAgICogb3RoZXJ3aXNlIGl0IGNsb25lcyB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEJpbmQgYWxsIG5lZWRlZCBldmVudHMuXG4gICAgICogQHBhcmFtIHBhZ2VYIExhdGVzdCBwb2ludGVyIHBvc2l0aW9uIG9uIHRoZSBYIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHBhZ2VZIExhdGVzdCBwb2ludGVyIHBvc2l0aW9uIG9uIHRoZSBZIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIE5vZGUgb2JqZWN0IHRvIGJlIGNsb25lZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlR2hvc3QocGFnZVg6IGFueSwgcGFnZVk6IGFueSwgbm9kZT86IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIERpc3BhdGNoIGN1c3RvbSBpZ3hEcmFnRW50ZXIvaWd4RHJhZ0xlYXZlIGV2ZW50cyBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gYW5kIGlmIGRyb3AgYXJlYSBpcyB1bmRlci5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcmFnRXZlbnRzKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIG9yaWdpbmFsRXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIERpc3BhdGNoIGN1c3RvbSBpZ3hEcm9wIGV2ZW50IGJhc2VkIG9uIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBpZiB0aGVyZSBpcyBsYXN0IHJlY29yZGVyIGRyb3AgYXJlYSB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBMYXN0IHJlY29yZGVyIGRyb3AgYXJlYSBpcyB1cGRhdGVkIGluIEBkaXNwYXRjaERyYWdFdmVudHMgbWV0aG9kLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaERyb3BFdmVudChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBvcmlnaW5hbEV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblRyYW5zaXRpb25FbmQoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFbGVtZW50c0F0UG9pbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcik6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRXZlbnQodGFyZ2V0OiBhbnksIGV2ZW50TmFtZTogc3RyaW5nLCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBnZXRUcmFuc2Zvcm1YKGVsZW06IGFueSk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0VHJhbnNmb3JtWShlbGVtOiBhbnkpOiBudW1iZXI7XG4gICAgLyoqIE1ldGhvZCBzZXR0aW5nIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBiYXNlIGRyYWdnYWJsZSBlbGVtZW50LiAqL1xuICAgIHByb3RlY3RlZCBzZXRUcmFuc2Zvcm1YWSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbFRvcCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbExlZnQoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRMZWZ0KGdob3N0SG9zdDogYW55KTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRUb3AoZ2hvc3RIb3N0OiBhbnkpOiBudW1iZXI7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hEcm9wRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfem9uZTtcbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcm9wYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyb3BgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyb3BdPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkYXRhOiBhbnk7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgcHJvdmlkZSBhIHdheSBmb3IgaWd4RHJhZyBhbmQgaWd4RHJvcCB0byBiZSBsaW5rZWQgdGhyb3VnaCBjaGFubmVscy5cbiAgICAgKiBJdCBhY2NlcHRzIHNpbmdsZSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMgYW5kIGV2YWx1YXRlcyB0aGVuIHVzaW5nIHN0cmljdCBlcXVhbGl0eS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnQ2hhbm5lbF09XCInb2RkJ1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+OTU8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcm9wIFtkcm9wQ2hhbm5lbF09XCJbJ29kZCcsICdpcnJhdGlvbmFsJ11cIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPk51bWJlcnMgZHJvcCBhcmVhITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyb3BDaGFubmVsOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSB8IHN0cmluZ1tdO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBhIGRyb3Agc3RyYXRlZ3kgdHlwZSB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhbiBgSWd4RHJhZ2AgZWxlbWVudCBpcyByZWxlYXNlZCBpbnNpZGVcbiAgICAgKiAgdGhlIGN1cnJlbnQgZHJvcCBhcmVhLiBUaGUgcHJvdmlkZWQgc3RyYXRlZ2llcyBhcmU6XG4gICAgICogIC0gSWd4RGVmYXVsdERyb3BTdHJhdGVneSAtIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmFzZSBzdHJhdGVneSBhbmQgaXQgZG9lc24ndCBwZXJmb3JtIGFueSBhY3Rpb25zLlxuICAgICAqICAtIElneEFwcGVuZERyb3BTdHJhdGVneSAtIEFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCB0byBsYXN0IHBvc2l0aW9uIGFzIGEgZGlyZWN0IGNoaWxkIHRvIHRoZSBgaWd4RHJvcGAuXG4gICAgICogIC0gSWd4UHJlcGVuZERyb3BTdHJhdGVneSAtIFByZXBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgdG8gZmlyc3QgcG9zaXRpb24gYXMgYSBkaXJlY3QgY2hpbGQgdG8gdGhlIGBpZ3hEcm9wYC5cbiAgICAgKiAgLSBJZ3hJbnNlcnREcm9wU3RyYXRlZ3kgLSBJZiB0aGUgZHJvcHBlZCBlbGVtZW50IGlzIHJlbGVhc2VkIGFib3ZlIGEgY2hpbGQgZWxlbWVudCBvZiB0aGUgYGlneERyb3BgLCBpdCB3aWxsIGJlIGluc2VydGVkXG4gICAgICogICAgICBhdCB0aGF0IHBvc2l0aW9uLiBPdGhlcndpc2UgdGhlIGRyb3BwZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkIGlmIHJlbGVhc2VkIG91dHNpZGUgYW55IGNoaWxkIG9mIHRoZSBgaWd4RHJvcGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZz5cbiAgICAgKiAgICAgIDxzcGFuPkRyYWdNZTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BTdHJhdGVneV09XCJteURyb3BTdHJhdGVneVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBJZ3hBcHBlbmREcm9wU3RyYXRlZ3kgfSBmcm9tICdpZ25pdGV1aS1hbmd1bGFyJztcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHAge1xuICAgICAqICAgICAgcHVibGljIG15RHJvcFN0cmF0ZWd5ID0gSWd4QXBwZW5kRHJvcFN0cmF0ZWd5O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIHNldCBkcm9wU3RyYXRlZ3koY2xhc3NSZWY6IGFueSk7XG4gICAgZ2V0IGRyb3BTdHJhdGVneSgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBlbnRlcjogRXZlbnRFbWl0dGVyPElEcm9wQmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBvdmVyOiBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgbGVhdmVzIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChsZWF2ZSk9XCJkcmFnTGVhdmUoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnTGVhdmUoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBsZWZ0IHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIGxlYXZlOiBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgaXMgZHJvcHBlZCBpbiB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBTaW5jZSB0aGUgYGlneERyb3BgIGhhcyBkZWZhdWx0IGxvZ2ljIHRoYXQgYXBwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IGFzIGEgY2hpbGQsIGl0IGNhbiBiZSBjYW5jZWxlZCBoZXJlLlxuICAgICAqIFRvIGNhbmNlbCB0aGUgZGVmYXVsdCBsb2dpYyB0aGUgYGNhbmNlbGAgcHJvcGVydHkgb2YgdGhlIGV2ZW50IG5lZWRzIHRvIGJlIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChkcm9wcGVkKT1cImRyYWdEcm9wKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0Ryb3AoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIGRyb3BwZWQgaW4gdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJvcHBlZDogRXZlbnRFbWl0dGVyPElEcm9wRHJvcHBlZEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyb3BwYWJsZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZHJhZ292ZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVzdHJveTogU3ViamVjdDxib29sZWFuPjtcbiAgICBwcm90ZWN0ZWQgX2Ryb3BTdHJhdGVneTogSURyb3BTdHJhdGVneTtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmLCBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgX3pvbmU6IE5nWm9uZSk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRHJhZ092ZXIoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRHJhZ0VudGVyKGV2ZW50OiBDdXN0b21FdmVudDxJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzPik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRHJhZ0xlYXZlKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdEcm9wKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxUb3AoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxMZWZ0KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgaXNEcmFnTGlua2VkKGRyYWc6IElneERyYWdEaXJlY3RpdmUpOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBnZXRJbnNlcnRJbmRleEF0KGRyYWdnZWREaXI6IElneERyYWdEaXJlY3RpdmUsIGVsZW1lbnRzQXRQb2ludDogYW55W10pOiBudW1iZXI7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4RHJhZ0Ryb3BNb2R1bGUge1xufVxuIl19